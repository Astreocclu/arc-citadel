# Enemy AI Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create a configurable, personality-driven Enemy AI system that makes strategic and tactical decisions through the existing order/courier system.

**Architecture:** Trait + Data hybrid where `trait BattleAI` defines the interface and TOML configs tune behavior. AI respects fog of war (configurable) and dispatches orders through the courier system like player commands.

**Tech Stack:** Rust, TOML (serde), existing battle systems

---

## Task 1: AI Module Structure and Trait Definition

**Files:**
- Create: `src/battle/ai/mod.rs`
- Modify: `src/battle/mod.rs` (add `pub mod ai;`)

**Step 1: Create the AI module root with trait definition**

```rust
// src/battle/ai/mod.rs
//! Enemy AI system for battle decision-making
//!
//! Architecture: Trait + Data hybrid
//! - BattleAI trait defines interface for swappable implementations
//! - AiPersonality struct holds TOML-loaded weights/preferences
//! - DecisionContext provides fog-of-war-filtered battle state

mod commander;
mod decision_context;
mod personality;
mod phase_plans;

pub use commander::AiCommander;
pub use decision_context::DecisionContext;
pub use personality::{AiPersonality, load_personality};
pub use phase_plans::{PhasePlan, PhaseTransition};

use crate::battle::courier::Order;
use crate::battle::execution::BattleEventLog;
use crate::core::types::Tick;

/// Trait for battle AI implementations
pub trait BattleAI {
    /// Process a single tick - returns orders to dispatch via courier
    fn process_tick(
        &mut self,
        context: &DecisionContext,
        current_tick: Tick,
        events: &mut BattleEventLog,
    ) -> Vec<Order>;

    /// Get the personality configuration
    fn personality(&self) -> &AiPersonality;

    /// Check if AI cheats on fog of war
    fn ignores_fog_of_war(&self) -> bool;
}
```

**Step 2: Add module to battle/mod.rs**

In `src/battle/mod.rs`, add:
```rust
pub mod ai;
```

**Step 3: Verify compilation**

Run: `cargo check --lib`
Expected: Warning about unused imports (acceptable at this stage)

**Step 4: Commit**

```bash
git add src/battle/ai/mod.rs src/battle/mod.rs
git commit -m "feat(battle): add AI module structure with BattleAI trait"
```

---

## Task 2: AiPersonality TOML Configuration

**Files:**
- Create: `src/battle/ai/personality.rs`
- Create: `data/ai_personalities/default.toml`
- Create: `data/ai_personalities/aggressive.toml`

**Step 1: Write the failing test**

```rust
// In src/battle/ai/personality.rs

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_load_default_personality() {
        let personality = load_personality("default").expect("Should load default personality");
        assert!(personality.behavior.aggression >= 0.0);
        assert!(personality.behavior.aggression <= 1.0);
    }

    #[test]
    fn test_personality_weights_bounded() {
        let personality = AiPersonality::default();
        assert!(personality.weights.attack_value >= 0.0);
        assert!(personality.weights.retreat_threshold >= 0.0);
        assert!(personality.weights.retreat_threshold <= 1.0);
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test --lib battle::ai::personality`
Expected: FAIL - module doesn't exist yet

**Step 3: Implement personality module**

```rust
// src/battle/ai/personality.rs
//! AI personality configuration loaded from TOML

use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;

/// Behavioral tendencies (0.0 to 1.0)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BehaviorConfig {
    /// Tendency to attack vs defend (0.0 = defensive, 1.0 = aggressive)
    pub aggression: f32,
    /// Tendency to avoid risks (0.0 = reckless, 1.0 = cautious)
    pub caution: f32,
    /// Tendency to act proactively (0.0 = reactive, 1.0 = proactive)
    pub initiative: f32,
    /// Tendency to use deception (feints, fake retreats)
    pub cunning: f32,
}

impl Default for BehaviorConfig {
    fn default() -> Self {
        Self {
            aggression: 0.5,
            caution: 0.5,
            initiative: 0.5,
            cunning: 0.3,
        }
    }
}

/// Decision weights for evaluating options
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WeightConfig {
    /// Weight for attacking weak/vulnerable units
    pub attack_value: f32,
    /// Weight for defending key positions
    pub defense_value: f32,
    /// Weight for flanking opportunities
    pub flanking_value: f32,
    /// Weight for preserving reserves
    pub reserve_value: f32,
    /// Strength ratio threshold to consider retreat
    pub retreat_threshold: f32,
    /// Casualty percentage to trigger withdrawal
    pub casualty_threshold: f32,
}

impl Default for WeightConfig {
    fn default() -> Self {
        Self {
            attack_value: 1.0,
            defense_value: 1.0,
            flanking_value: 1.2,
            reserve_value: 0.8,
            retreat_threshold: 0.3,
            casualty_threshold: 0.5,
        }
    }
}

/// Tactical preferences
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PreferencesConfig {
    /// Preferred engagement range: "close", "medium", "ranged"
    pub preferred_range: String,
    /// Reserve commitment style: "early", "conservative", "desperate"
    pub reserve_usage: String,
    /// How often to re-evaluate plans (in ticks)
    pub re_evaluation_interval: u64,
}

impl Default for PreferencesConfig {
    fn default() -> Self {
        Self {
            preferred_range: "medium".to_string(),
            reserve_usage: "conservative".to_string(),
            re_evaluation_interval: 10,
        }
    }
}

/// Difficulty modifiers
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DifficultyConfig {
    /// Whether AI ignores fog of war
    pub ignores_fog_of_war: bool,
    /// Reaction delay in ticks (0 = instant, higher = slower)
    pub reaction_delay: u64,
    /// Mistake probability (0.0 = perfect, 1.0 = always mistakes)
    pub mistake_chance: f32,
}

impl Default for DifficultyConfig {
    fn default() -> Self {
        Self {
            ignores_fog_of_war: false,
            reaction_delay: 2,
            mistake_chance: 0.1,
        }
    }
}

/// Complete AI personality configuration
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct AiPersonality {
    pub name: String,
    pub behavior: BehaviorConfig,
    pub weights: WeightConfig,
    pub preferences: PreferencesConfig,
    pub difficulty: DifficultyConfig,
}

/// Load personality from TOML file
pub fn load_personality(name: &str) -> Result<AiPersonality, String> {
    let path = personality_path(name);

    let contents = fs::read_to_string(&path)
        .map_err(|e| format!("Failed to read personality file {:?}: {}", path, e))?;

    let mut personality: AiPersonality = toml::from_str(&contents)
        .map_err(|e| format!("Failed to parse personality TOML: {}", e))?;

    personality.name = name.to_string();
    Ok(personality)
}

/// Get path to personality file
fn personality_path(name: &str) -> PathBuf {
    PathBuf::from("data/ai_personalities").join(format!("{}.toml", name))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_load_default_personality() {
        let personality = load_personality("default").expect("Should load default personality");
        assert!(personality.behavior.aggression >= 0.0);
        assert!(personality.behavior.aggression <= 1.0);
    }

    #[test]
    fn test_personality_weights_bounded() {
        let personality = AiPersonality::default();
        assert!(personality.weights.attack_value >= 0.0);
        assert!(personality.weights.retreat_threshold >= 0.0);
        assert!(personality.weights.retreat_threshold <= 1.0);
    }

    #[test]
    fn test_default_personality_values() {
        let personality = AiPersonality::default();
        assert_eq!(personality.behavior.aggression, 0.5);
        assert_eq!(personality.difficulty.ignores_fog_of_war, false);
    }
}
```

**Step 4: Create default.toml personality file**

```toml
# data/ai_personalities/default.toml
# Balanced AI personality - neither aggressive nor defensive

[behavior]
aggression = 0.5
caution = 0.5
initiative = 0.5
cunning = 0.3

[weights]
attack_value = 1.0
defense_value = 1.0
flanking_value = 1.2
reserve_value = 0.8
retreat_threshold = 0.3
casualty_threshold = 0.5

[preferences]
preferred_range = "medium"
reserve_usage = "conservative"
re_evaluation_interval = 10

[difficulty]
ignores_fog_of_war = false
reaction_delay = 2
mistake_chance = 0.1
```

**Step 5: Create aggressive.toml personality file**

```toml
# data/ai_personalities/aggressive.toml
# Aggressive commander - attacks early, takes risks

[behavior]
aggression = 0.8
caution = 0.2
initiative = 0.9
cunning = 0.4

[weights]
attack_value = 1.5
defense_value = 0.6
flanking_value = 1.4
reserve_value = 0.4
retreat_threshold = 0.15
casualty_threshold = 0.7

[preferences]
preferred_range = "close"
reserve_usage = "early"
re_evaluation_interval = 5

[difficulty]
ignores_fog_of_war = false
reaction_delay = 1
mistake_chance = 0.15
```

**Step 6: Update mod.rs exports**

Ensure `src/battle/ai/mod.rs` has:
```rust
mod personality;
pub use personality::{AiPersonality, load_personality};
```

**Step 7: Run tests to verify**

Run: `cargo test --lib battle::ai::personality`
Expected: PASS

**Step 8: Commit**

```bash
git add src/battle/ai/personality.rs data/ai_personalities/
git commit -m "feat(battle): add AiPersonality TOML configuration system"
```

---

## Task 3: DecisionContext (Fog-of-War Filtered View)

**Files:**
- Create: `src/battle/ai/decision_context.rs`

**Step 1: Write the failing test**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::battle::hex::BattleHexCoord;
    use crate::battle::units::{Army, ArmyId, BattleFormation, BattleUnit, Element, FormationId, UnitId};
    use crate::battle::unit_type::UnitType;
    use crate::battle::visibility::ArmyVisibility;
    use crate::core::types::EntityId;
    use std::collections::HashSet;

    fn create_test_unit(pos: BattleHexCoord) -> BattleUnit {
        let mut unit = BattleUnit::new(UnitId::new(), UnitType::Infantry);
        unit.position = pos;
        unit.elements.push(Element::new(vec![EntityId::new(); 50]));
        unit
    }

    #[test]
    fn test_visible_enemy_units_respects_fog() {
        let mut own_army = Army::new(ArmyId::new(), EntityId::new());
        let mut enemy_army = Army::new(ArmyId::new(), EntityId::new());

        // Own unit at (5,5)
        let mut own_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        own_formation.units.push(create_test_unit(BattleHexCoord::new(5, 5)));
        own_army.formations.push(own_formation);

        // Enemy units at (6,5) visible and (20,20) not visible
        let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        enemy_formation.units.push(create_test_unit(BattleHexCoord::new(6, 5)));
        enemy_formation.units.push(create_test_unit(BattleHexCoord::new(20, 20)));
        enemy_army.formations.push(enemy_formation);

        // Visibility only includes (6,5)
        let mut visibility = ArmyVisibility::new();
        let mut visible = HashSet::new();
        visible.insert(BattleHexCoord::new(5, 5));
        visible.insert(BattleHexCoord::new(6, 5));
        visibility.update(visible);

        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 0, false);
        let visible_enemies = context.visible_enemy_units();

        assert_eq!(visible_enemies.len(), 1);
        assert_eq!(visible_enemies[0].position, BattleHexCoord::new(6, 5));
    }

    #[test]
    fn test_ignores_fog_sees_all() {
        let own_army = Army::new(ArmyId::new(), EntityId::new());
        let mut enemy_army = Army::new(ArmyId::new(), EntityId::new());

        let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        enemy_formation.units.push(create_test_unit(BattleHexCoord::new(6, 5)));
        enemy_formation.units.push(create_test_unit(BattleHexCoord::new(20, 20)));
        enemy_army.formations.push(enemy_formation);

        // Empty visibility but ignores_fog = true
        let visibility = ArmyVisibility::new();
        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 0, true);
        let visible_enemies = context.visible_enemy_units();

        assert_eq!(visible_enemies.len(), 2);
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test --lib battle::ai::decision_context`
Expected: FAIL - module doesn't exist

**Step 3: Implement DecisionContext**

```rust
// src/battle/ai/decision_context.rs
//! AI's filtered view of the battle state
//!
//! Respects fog of war unless ignores_fog_of_war is true.

use crate::battle::hex::BattleHexCoord;
use crate::battle::units::{Army, BattleUnit, UnitId};
use crate::battle::visibility::ArmyVisibility;
use crate::core::types::Tick;

/// AI's decision-making context
///
/// Provides a filtered view of the battle respecting fog of war.
pub struct DecisionContext<'a> {
    pub own_army: &'a Army,
    pub enemy_army: &'a Army,
    pub own_visibility: &'a ArmyVisibility,
    pub current_tick: Tick,
    ignores_fog: bool,
}

impl<'a> DecisionContext<'a> {
    pub fn new(
        own_army: &'a Army,
        enemy_army: &'a Army,
        own_visibility: &'a ArmyVisibility,
        current_tick: Tick,
        ignores_fog: bool,
    ) -> Self {
        Self {
            own_army,
            enemy_army,
            own_visibility,
            current_tick,
            ignores_fog,
        }
    }

    /// Get all own units
    pub fn own_units(&self) -> Vec<&BattleUnit> {
        self.own_army
            .formations
            .iter()
            .flat_map(|f| f.units.iter())
            .collect()
    }

    /// Get enemy units that are visible (or all if ignoring fog)
    pub fn visible_enemy_units(&self) -> Vec<&BattleUnit> {
        self.enemy_army
            .formations
            .iter()
            .flat_map(|f| f.units.iter())
            .filter(|u| self.ignores_fog || self.own_visibility.is_visible(u.position))
            .collect()
    }

    /// Get a specific own unit by ID
    pub fn get_own_unit(&self, unit_id: UnitId) -> Option<&BattleUnit> {
        self.own_army.get_unit(unit_id)
    }

    /// Check if a position is visible
    pub fn is_visible(&self, pos: BattleHexCoord) -> bool {
        self.ignores_fog || self.own_visibility.is_visible(pos)
    }

    /// Calculate own army effective strength
    pub fn own_effective_strength(&self) -> usize {
        self.own_army.effective_strength()
    }

    /// Calculate visible enemy effective strength
    pub fn visible_enemy_strength(&self) -> usize {
        self.visible_enemy_units()
            .iter()
            .map(|u| u.effective_strength())
            .sum()
    }

    /// Calculate strength ratio (own / enemy)
    /// Returns f32::MAX if no visible enemies
    pub fn strength_ratio(&self) -> f32 {
        let enemy_strength = self.visible_enemy_strength();
        if enemy_strength == 0 {
            return f32::MAX;
        }
        self.own_effective_strength() as f32 / enemy_strength as f32
    }

    /// Find weakest visible enemy unit
    pub fn weakest_enemy(&self) -> Option<&BattleUnit> {
        self.visible_enemy_units()
            .into_iter()
            .min_by_key(|u| u.effective_strength())
    }

    /// Find closest enemy to a position
    pub fn closest_enemy_to(&self, pos: BattleHexCoord) -> Option<&BattleUnit> {
        self.visible_enemy_units()
            .into_iter()
            .min_by_key(|u| u.position.distance(&pos) as u32)
    }

    /// Get all units that are routing
    pub fn routing_own_units(&self) -> Vec<&BattleUnit> {
        self.own_units()
            .into_iter()
            .filter(|u| u.is_broken())
            .collect()
    }

    /// Calculate own casualty percentage
    pub fn own_casualty_percentage(&self) -> f32 {
        let total = self.own_army.total_strength();
        if total == 0 {
            return 0.0;
        }
        let effective = self.own_army.effective_strength();
        1.0 - (effective as f32 / total as f32)
    }

    /// Get own HQ position
    pub fn hq_position(&self) -> BattleHexCoord {
        self.own_army.hq_position
    }

    /// Get available couriers
    pub fn available_couriers(&self) -> usize {
        self.own_army.courier_pool.len()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::battle::hex::BattleHexCoord;
    use crate::battle::units::{Army, ArmyId, BattleFormation, BattleUnit, Element, FormationId, UnitId};
    use crate::battle::unit_type::UnitType;
    use crate::battle::visibility::ArmyVisibility;
    use crate::core::types::EntityId;
    use std::collections::HashSet;

    fn create_test_unit(pos: BattleHexCoord) -> BattleUnit {
        let mut unit = BattleUnit::new(UnitId::new(), UnitType::Infantry);
        unit.position = pos;
        unit.elements.push(Element::new(vec![EntityId::new(); 50]));
        unit
    }

    #[test]
    fn test_visible_enemy_units_respects_fog() {
        let mut own_army = Army::new(ArmyId::new(), EntityId::new());
        let mut enemy_army = Army::new(ArmyId::new(), EntityId::new());

        let mut own_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        own_formation.units.push(create_test_unit(BattleHexCoord::new(5, 5)));
        own_army.formations.push(own_formation);

        let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        enemy_formation.units.push(create_test_unit(BattleHexCoord::new(6, 5)));
        enemy_formation.units.push(create_test_unit(BattleHexCoord::new(20, 20)));
        enemy_army.formations.push(enemy_formation);

        let mut visibility = ArmyVisibility::new();
        let mut visible = HashSet::new();
        visible.insert(BattleHexCoord::new(5, 5));
        visible.insert(BattleHexCoord::new(6, 5));
        visibility.update(visible);

        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 0, false);
        let visible_enemies = context.visible_enemy_units();

        assert_eq!(visible_enemies.len(), 1);
        assert_eq!(visible_enemies[0].position, BattleHexCoord::new(6, 5));
    }

    #[test]
    fn test_ignores_fog_sees_all() {
        let own_army = Army::new(ArmyId::new(), EntityId::new());
        let mut enemy_army = Army::new(ArmyId::new(), EntityId::new());

        let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        enemy_formation.units.push(create_test_unit(BattleHexCoord::new(6, 5)));
        enemy_formation.units.push(create_test_unit(BattleHexCoord::new(20, 20)));
        enemy_army.formations.push(enemy_formation);

        let visibility = ArmyVisibility::new();
        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 0, true);
        let visible_enemies = context.visible_enemy_units();

        assert_eq!(visible_enemies.len(), 2);
    }

    #[test]
    fn test_strength_ratio_calculation() {
        let mut own_army = Army::new(ArmyId::new(), EntityId::new());
        let mut enemy_army = Army::new(ArmyId::new(), EntityId::new());

        let mut own_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        own_formation.units.push(create_test_unit(BattleHexCoord::new(5, 5)));
        own_army.formations.push(own_formation);

        let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        enemy_formation.units.push(create_test_unit(BattleHexCoord::new(6, 5)));
        enemy_army.formations.push(enemy_formation);

        let mut visibility = ArmyVisibility::new();
        let mut visible = HashSet::new();
        visible.insert(BattleHexCoord::new(6, 5));
        visibility.update(visible);

        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 0, false);

        // Both have 50 strength, ratio should be 1.0
        assert!((context.strength_ratio() - 1.0).abs() < 0.01);
    }

    #[test]
    fn test_weakest_enemy() {
        let own_army = Army::new(ArmyId::new(), EntityId::new());
        let mut enemy_army = Army::new(ArmyId::new(), EntityId::new());

        let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());

        // Strong unit
        let mut strong = BattleUnit::new(UnitId::new(), UnitType::Infantry);
        strong.position = BattleHexCoord::new(6, 5);
        strong.elements.push(Element::new(vec![EntityId::new(); 100]));
        enemy_formation.units.push(strong);

        // Weak unit
        let mut weak = BattleUnit::new(UnitId::new(), UnitType::Infantry);
        weak.position = BattleHexCoord::new(7, 5);
        weak.elements.push(Element::new(vec![EntityId::new(); 20]));
        enemy_formation.units.push(weak);

        enemy_army.formations.push(enemy_formation);

        let context = DecisionContext::new(&own_army, &enemy_army, &ArmyVisibility::new(), 0, true);
        let weakest = context.weakest_enemy().expect("Should find weakest");

        assert_eq!(weakest.effective_strength(), 20);
    }
}
```

**Step 4: Update mod.rs exports**

```rust
mod decision_context;
pub use decision_context::DecisionContext;
```

**Step 5: Run tests**

Run: `cargo test --lib battle::ai::decision_context`
Expected: PASS

**Step 6: Commit**

```bash
git add src/battle/ai/decision_context.rs
git commit -m "feat(battle): add DecisionContext with fog-of-war filtering"
```

---

## Task 4: Phase Plans (Multi-Phase Battle Planning)

**Files:**
- Create: `src/battle/ai/phase_plans.rs`

**Step 1: Write the failing test**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_time_transition() {
        let transition = PhaseTransition::TimeElapsed(100);
        assert!(transition.is_triggered(100, 0.5, 0.1));
        assert!(!transition.is_triggered(50, 0.5, 0.1));
    }

    #[test]
    fn test_strength_ratio_transition() {
        let transition = PhaseTransition::StrengthRatioBelow(0.5);
        assert!(transition.is_triggered(0, 0.3, 0.1));
        assert!(!transition.is_triggered(0, 0.7, 0.1));
    }

    #[test]
    fn test_phase_plan_manager_advances() {
        let mut manager = PhasePlanManager::new();
        manager.add_phase(PhasePlan {
            name: "Opening".to_string(),
            priority_targets: vec![],
            reserve_commitment: 0.0,
            aggression_modifier: 0.0,
            transition: PhaseTransition::TimeElapsed(10),
        });
        manager.add_phase(PhasePlan {
            name: "Main".to_string(),
            priority_targets: vec![],
            reserve_commitment: 0.5,
            aggression_modifier: 0.2,
            transition: PhaseTransition::Never,
        });

        assert_eq!(manager.current_phase().name, "Opening");

        // Simulate time passing
        manager.update(10, 1.0, 0.1);
        assert_eq!(manager.current_phase().name, "Main");
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test --lib battle::ai::phase_plans`
Expected: FAIL

**Step 3: Implement phase plans**

```rust
// src/battle/ai/phase_plans.rs
//! Multi-phase battle planning
//!
//! AI can have different strategies for different battle phases:
//! - Opening: probing, positioning
//! - Main assault: committed attack
//! - Exploitation: pursuit of routed enemies
//! - Withdrawal: organized retreat

use serde::{Deserialize, Serialize};

use crate::battle::hex::BattleHexCoord;
use crate::core::types::Tick;

/// Condition that triggers phase transition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PhaseTransition {
    /// Transition after N ticks
    TimeElapsed(Tick),
    /// Transition when strength ratio falls below threshold
    StrengthRatioBelow(f32),
    /// Transition when casualties exceed percentage
    CasualtiesExceed(f32),
    /// Manual transition only (via contingency or go-code)
    Manual,
    /// Never transition (final phase)
    Never,
}

impl PhaseTransition {
    /// Check if transition condition is met
    pub fn is_triggered(&self, current_tick: Tick, strength_ratio: f32, casualties: f32) -> bool {
        match self {
            PhaseTransition::TimeElapsed(tick) => current_tick >= *tick,
            PhaseTransition::StrengthRatioBelow(threshold) => strength_ratio < *threshold,
            PhaseTransition::CasualtiesExceed(threshold) => casualties > *threshold,
            PhaseTransition::Manual => false,
            PhaseTransition::Never => false,
        }
    }
}

/// A phase of the battle plan
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PhasePlan {
    /// Name of this phase
    pub name: String,
    /// Priority target positions
    pub priority_targets: Vec<BattleHexCoord>,
    /// How much of reserves to commit (0.0 to 1.0)
    pub reserve_commitment: f32,
    /// Modifier to base aggression (-1.0 to 1.0)
    pub aggression_modifier: f32,
    /// Condition to transition to next phase
    pub transition: PhaseTransition,
}

impl Default for PhasePlan {
    fn default() -> Self {
        Self {
            name: "Default".to_string(),
            priority_targets: Vec::new(),
            reserve_commitment: 0.0,
            aggression_modifier: 0.0,
            transition: PhaseTransition::Never,
        }
    }
}

/// Manager for multi-phase battle plans
#[derive(Debug, Clone, Default)]
pub struct PhasePlanManager {
    phases: Vec<PhasePlan>,
    current_phase_index: usize,
    phase_start_tick: Tick,
}

impl PhasePlanManager {
    pub fn new() -> Self {
        Self {
            phases: vec![PhasePlan::default()],
            current_phase_index: 0,
            phase_start_tick: 0,
        }
    }

    /// Add a phase to the plan
    pub fn add_phase(&mut self, phase: PhasePlan) {
        // If only default phase exists, replace it
        if self.phases.len() == 1 && self.phases[0].name == "Default" {
            self.phases[0] = phase;
        } else {
            self.phases.push(phase);
        }
    }

    /// Get current phase
    pub fn current_phase(&self) -> &PhasePlan {
        &self.phases[self.current_phase_index]
    }

    /// Update and potentially transition phases
    pub fn update(&mut self, current_tick: Tick, strength_ratio: f32, casualties: f32) {
        let ticks_in_phase = current_tick.saturating_sub(self.phase_start_tick);

        if self.current_phase().transition.is_triggered(ticks_in_phase, strength_ratio, casualties) {
            self.advance_phase(current_tick);
        }
    }

    /// Advance to next phase
    fn advance_phase(&mut self, current_tick: Tick) {
        if self.current_phase_index < self.phases.len() - 1 {
            self.current_phase_index += 1;
            self.phase_start_tick = current_tick;
        }
    }

    /// Force transition to next phase
    pub fn force_advance(&mut self, current_tick: Tick) {
        self.advance_phase(current_tick);
    }

    /// Check if in final phase
    pub fn is_final_phase(&self) -> bool {
        self.current_phase_index >= self.phases.len() - 1
    }

    /// Get phase index
    pub fn phase_index(&self) -> usize {
        self.current_phase_index
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_time_transition() {
        let transition = PhaseTransition::TimeElapsed(100);
        assert!(transition.is_triggered(100, 0.5, 0.1));
        assert!(!transition.is_triggered(50, 0.5, 0.1));
    }

    #[test]
    fn test_strength_ratio_transition() {
        let transition = PhaseTransition::StrengthRatioBelow(0.5);
        assert!(transition.is_triggered(0, 0.3, 0.1));
        assert!(!transition.is_triggered(0, 0.7, 0.1));
    }

    #[test]
    fn test_casualties_transition() {
        let transition = PhaseTransition::CasualtiesExceed(0.5);
        assert!(transition.is_triggered(0, 1.0, 0.6));
        assert!(!transition.is_triggered(0, 1.0, 0.3));
    }

    #[test]
    fn test_never_transition() {
        let transition = PhaseTransition::Never;
        assert!(!transition.is_triggered(1000, 0.0, 1.0));
    }

    #[test]
    fn test_phase_plan_manager_advances() {
        let mut manager = PhasePlanManager::new();
        manager.add_phase(PhasePlan {
            name: "Opening".to_string(),
            priority_targets: vec![],
            reserve_commitment: 0.0,
            aggression_modifier: 0.0,
            transition: PhaseTransition::TimeElapsed(10),
        });
        manager.add_phase(PhasePlan {
            name: "Main".to_string(),
            priority_targets: vec![],
            reserve_commitment: 0.5,
            aggression_modifier: 0.2,
            transition: PhaseTransition::Never,
        });

        assert_eq!(manager.current_phase().name, "Opening");

        manager.update(10, 1.0, 0.1);
        assert_eq!(manager.current_phase().name, "Main");
    }

    #[test]
    fn test_phase_stays_on_final() {
        let mut manager = PhasePlanManager::new();
        manager.add_phase(PhasePlan {
            name: "Only".to_string(),
            priority_targets: vec![],
            reserve_commitment: 0.0,
            aggression_modifier: 0.0,
            transition: PhaseTransition::TimeElapsed(1),
        });

        manager.update(100, 1.0, 0.0);
        assert!(manager.is_final_phase());
        assert_eq!(manager.current_phase().name, "Only");
    }

    #[test]
    fn test_force_advance() {
        let mut manager = PhasePlanManager::new();
        manager.add_phase(PhasePlan {
            name: "First".to_string(),
            priority_targets: vec![],
            reserve_commitment: 0.0,
            aggression_modifier: 0.0,
            transition: PhaseTransition::Never,
        });
        manager.add_phase(PhasePlan {
            name: "Second".to_string(),
            priority_targets: vec![],
            reserve_commitment: 0.0,
            aggression_modifier: 0.0,
            transition: PhaseTransition::Never,
        });

        assert_eq!(manager.current_phase().name, "First");
        manager.force_advance(50);
        assert_eq!(manager.current_phase().name, "Second");
    }
}
```

**Step 4: Update mod.rs exports**

```rust
mod phase_plans;
pub use phase_plans::{PhasePlan, PhaseTransition, PhasePlanManager};
```

**Step 5: Run tests**

Run: `cargo test --lib battle::ai::phase_plans`
Expected: PASS

**Step 6: Commit**

```bash
git add src/battle/ai/phase_plans.rs
git commit -m "feat(battle): add multi-phase battle planning system"
```

---

## Task 5: AiCommander Implementation

**Files:**
- Create: `src/battle/ai/commander.rs`

**Step 1: Write the failing test**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use crate::battle::ai::personality::AiPersonality;

    #[test]
    fn test_commander_creation() {
        let personality = AiPersonality::default();
        let commander = AiCommander::new(personality);
        assert!(!commander.ignores_fog_of_war());
    }

    #[test]
    fn test_commander_process_tick_returns_orders() {
        let personality = AiPersonality::default();
        let mut commander = AiCommander::new(personality);

        // Create minimal context
        let own_army = Army::new(ArmyId::new(), EntityId::new());
        let enemy_army = Army::new(ArmyId::new(), EntityId::new());
        let visibility = ArmyVisibility::new();
        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 0, false);
        let mut events = BattleEventLog::new();

        let orders = commander.process_tick(&context, 0, &mut events);

        // With no units, should return no orders
        assert!(orders.is_empty());
    }
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test --lib battle::ai::commander`
Expected: FAIL

**Step 3: Implement AiCommander**

```rust
// src/battle/ai/commander.rs
//! AI Commander - main battle AI implementation
//!
//! Evaluates battle state and issues orders through courier system.

use rand::rngs::StdRng;
use rand::{Rng, SeedableRng};

use crate::battle::ai::decision_context::DecisionContext;
use crate::battle::ai::personality::AiPersonality;
use crate::battle::ai::phase_plans::PhasePlanManager;
use crate::battle::ai::BattleAI;
use crate::battle::courier::{Order, OrderType};
use crate::battle::execution::BattleEventLog;
use crate::battle::hex::BattleHexCoord;
use crate::battle::units::{BattleUnit, UnitId, UnitStance};
use crate::core::types::Tick;

/// AI Commander implementing BattleAI trait
pub struct AiCommander {
    personality: AiPersonality,
    phase_manager: PhasePlanManager,
    last_evaluation_tick: Tick,
    rng: StdRng,
    /// Track which units have pending orders (to avoid spamming)
    pending_orders: Vec<UnitId>,
}

impl AiCommander {
    pub fn new(personality: AiPersonality) -> Self {
        Self {
            personality,
            phase_manager: PhasePlanManager::new(),
            last_evaluation_tick: 0,
            rng: StdRng::seed_from_u64(42), // Deterministic for testing
            pending_orders: Vec::new(),
        }
    }

    /// Create with specific RNG seed
    pub fn with_seed(personality: AiPersonality, seed: u64) -> Self {
        Self {
            personality,
            phase_manager: PhasePlanManager::new(),
            last_evaluation_tick: 0,
            rng: StdRng::seed_from_u64(seed),
            pending_orders: Vec::new(),
        }
    }

    /// Set the phase plan
    pub fn set_phase_manager(&mut self, manager: PhasePlanManager) {
        self.phase_manager = manager;
    }

    /// Should we re-evaluate this tick?
    fn should_evaluate(&self, current_tick: Tick) -> bool {
        let interval = self.personality.preferences.re_evaluation_interval;
        current_tick >= self.last_evaluation_tick + interval
    }

    /// Roll for making a mistake
    fn makes_mistake(&mut self) -> bool {
        self.rng.gen::<f32>() < self.personality.difficulty.mistake_chance
    }

    /// Evaluate tactical situation and decide orders
    fn evaluate_tactical(&mut self, context: &DecisionContext) -> Vec<Order> {
        let mut orders = Vec::new();

        // Get effective aggression (base + phase modifier)
        let phase = self.phase_manager.current_phase();
        let effective_aggression = (self.personality.behavior.aggression
            + phase.aggression_modifier).clamp(0.0, 1.0);

        // Check if we should retreat
        if self.should_retreat(context) {
            return self.generate_retreat_orders(context);
        }

        // Get idle units that need orders
        let idle_units: Vec<&BattleUnit> = context
            .own_units()
            .into_iter()
            .filter(|u| self.unit_needs_orders(u))
            .collect();

        for unit in idle_units {
            if self.pending_orders.contains(&unit.id) {
                continue;
            }

            if let Some(order) = self.decide_unit_order(unit, context, effective_aggression) {
                // Apply reaction delay via mistake - skip order randomly
                if !self.makes_mistake() {
                    self.pending_orders.push(unit.id);
                    orders.push(order);
                }
            }
        }

        orders
    }

    /// Check if unit needs new orders
    fn unit_needs_orders(&self, unit: &BattleUnit) -> bool {
        matches!(unit.stance, UnitStance::Formed | UnitStance::Alert)
            && unit.can_fight()
    }

    /// Decide what order to give a specific unit
    fn decide_unit_order(
        &mut self,
        unit: &BattleUnit,
        context: &DecisionContext,
        aggression: f32,
    ) -> Option<Order> {
        let visible_enemies = context.visible_enemy_units();

        if visible_enemies.is_empty() {
            return None;
        }

        // Find best target based on personality weights
        let target = self.select_target(unit, &visible_enemies, context)?;

        // Decide action based on aggression
        if aggression > 0.5 {
            // Aggressive: attack
            Some(Order::attack(unit.id, target.id))
        } else {
            // Defensive: move towards but hold
            let halfway = unit.position.lerp(&target.position, 0.5);
            Some(Order::move_to(unit.id, halfway))
        }
    }

    /// Select best target for a unit
    fn select_target<'a>(
        &self,
        unit: &BattleUnit,
        enemies: &[&'a BattleUnit],
        _context: &DecisionContext,
    ) -> Option<&'a BattleUnit> {
        if enemies.is_empty() {
            return None;
        }

        let weights = &self.personality.weights;

        // Score each enemy
        let mut best_score = f32::MIN;
        let mut best_target = None;

        for enemy in enemies {
            let mut score = 0.0;

            // Weak targets are attractive
            let weakness = 1.0 - (enemy.effective_strength() as f32 / 100.0).min(1.0);
            score += weakness * weights.attack_value;

            // Close targets are easier
            let distance = unit.position.distance(&enemy.position) as f32;
            let closeness = 1.0 / (1.0 + distance * 0.1);
            score += closeness * 0.5;

            // Flanking opportunities (simplified: check if enemy is engaged)
            if enemy.is_engaged() {
                score += weights.flanking_value * 0.5;
            }

            // Routing enemies are priority
            if enemy.is_broken() {
                score += 1.0;
            }

            if score > best_score {
                best_score = score;
                best_target = Some(*enemy);
            }
        }

        best_target
    }

    /// Check if we should retreat
    fn should_retreat(&self, context: &DecisionContext) -> bool {
        let ratio = context.strength_ratio();
        let casualties = context.own_casualty_percentage();

        ratio < self.personality.weights.retreat_threshold
            || casualties > self.personality.weights.casualty_threshold
    }

    /// Generate retreat orders for all units
    fn generate_retreat_orders(&self, context: &DecisionContext) -> Vec<Order> {
        let hq = context.hq_position();

        context
            .own_units()
            .iter()
            .filter(|u| u.can_fight() && !u.is_broken())
            .map(|u| Order::move_to(u.id, hq))
            .collect()
    }

    /// Clear pending orders for units that have received them
    pub fn clear_pending(&mut self, delivered_unit_ids: &[UnitId]) {
        self.pending_orders.retain(|id| !delivered_unit_ids.contains(id));
    }
}

impl BattleAI for AiCommander {
    fn process_tick(
        &mut self,
        context: &DecisionContext,
        current_tick: Tick,
        _events: &mut BattleEventLog,
    ) -> Vec<Order> {
        // Update phase transitions
        self.phase_manager.update(
            current_tick,
            context.strength_ratio(),
            context.own_casualty_percentage(),
        );

        // Only evaluate at intervals
        if !self.should_evaluate(current_tick) {
            return Vec::new();
        }

        self.last_evaluation_tick = current_tick;

        // Evaluate and return orders
        self.evaluate_tactical(context)
    }

    fn personality(&self) -> &AiPersonality {
        &self.personality
    }

    fn ignores_fog_of_war(&self) -> bool {
        self.personality.difficulty.ignores_fog_of_war
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::battle::ai::personality::AiPersonality;
    use crate::battle::hex::BattleHexCoord;
    use crate::battle::unit_type::UnitType;
    use crate::battle::units::{Army, ArmyId, BattleFormation, BattleUnit, Element, FormationId, UnitId};
    use crate::battle::visibility::ArmyVisibility;
    use crate::core::types::EntityId;

    fn create_test_unit_at(pos: BattleHexCoord, stance: UnitStance) -> BattleUnit {
        let mut unit = BattleUnit::new(UnitId::new(), UnitType::Infantry);
        unit.position = pos;
        unit.elements.push(Element::new(vec![EntityId::new(); 50]));
        unit.stance = stance;
        unit
    }

    #[test]
    fn test_commander_creation() {
        let personality = AiPersonality::default();
        let commander = AiCommander::new(personality);
        assert!(!commander.ignores_fog_of_war());
    }

    #[test]
    fn test_commander_process_tick_returns_orders() {
        let personality = AiPersonality::default();
        let mut commander = AiCommander::new(personality);

        let own_army = Army::new(ArmyId::new(), EntityId::new());
        let enemy_army = Army::new(ArmyId::new(), EntityId::new());
        let visibility = ArmyVisibility::new();
        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 0, false);
        let mut events = BattleEventLog::new();

        let orders = commander.process_tick(&context, 0, &mut events);

        assert!(orders.is_empty());
    }

    #[test]
    fn test_commander_attacks_visible_enemy() {
        let mut personality = AiPersonality::default();
        personality.behavior.aggression = 0.8; // Aggressive
        personality.preferences.re_evaluation_interval = 1;

        let mut commander = AiCommander::new(personality);

        // Setup armies
        let mut own_army = Army::new(ArmyId::new(), EntityId::new());
        let mut own_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        own_formation.units.push(create_test_unit_at(BattleHexCoord::new(5, 5), UnitStance::Formed));
        own_army.formations.push(own_formation);

        let mut enemy_army = Army::new(ArmyId::new(), EntityId::new());
        let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        enemy_formation.units.push(create_test_unit_at(BattleHexCoord::new(10, 5), UnitStance::Formed));
        enemy_army.formations.push(enemy_formation);

        // Full visibility
        let visibility = ArmyVisibility::new();
        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 0, true);
        let mut events = BattleEventLog::new();

        let orders = commander.process_tick(&context, 0, &mut events);

        assert!(!orders.is_empty(), "Should generate attack order");
        assert!(matches!(orders[0].order_type, OrderType::Attack(_)));
    }

    #[test]
    fn test_commander_retreats_when_outnumbered() {
        let mut personality = AiPersonality::default();
        personality.weights.retreat_threshold = 0.5;
        personality.preferences.re_evaluation_interval = 1;

        let mut commander = AiCommander::new(personality);

        // Small own army
        let mut own_army = Army::new(ArmyId::new(), EntityId::new());
        own_army.hq_position = BattleHexCoord::new(0, 0);
        let mut own_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        let mut small_unit = BattleUnit::new(UnitId::new(), UnitType::Infantry);
        small_unit.position = BattleHexCoord::new(10, 10);
        small_unit.elements.push(Element::new(vec![EntityId::new(); 20]));
        small_unit.stance = UnitStance::Formed;
        own_formation.units.push(small_unit);
        own_army.formations.push(own_formation);

        // Large enemy army
        let mut enemy_army = Army::new(ArmyId::new(), EntityId::new());
        let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        let mut large_unit = BattleUnit::new(UnitId::new(), UnitType::Infantry);
        large_unit.position = BattleHexCoord::new(12, 10);
        large_unit.elements.push(Element::new(vec![EntityId::new(); 200]));
        large_unit.stance = UnitStance::Formed;
        enemy_formation.units.push(large_unit);
        enemy_army.formations.push(enemy_formation);

        let visibility = ArmyVisibility::new();
        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 0, true);
        let mut events = BattleEventLog::new();

        let orders = commander.process_tick(&context, 0, &mut events);

        // Should retreat to HQ
        assert!(!orders.is_empty(), "Should generate retreat orders");
        if let OrderType::MoveTo(dest) = &orders[0].order_type {
            assert_eq!(*dest, BattleHexCoord::new(0, 0));
        } else {
            panic!("Expected MoveTo order for retreat");
        }
    }

    #[test]
    fn test_commander_respects_evaluation_interval() {
        let mut personality = AiPersonality::default();
        personality.preferences.re_evaluation_interval = 10;
        personality.behavior.aggression = 0.8;

        let mut commander = AiCommander::new(personality);

        let mut own_army = Army::new(ArmyId::new(), EntityId::new());
        let mut own_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        own_formation.units.push(create_test_unit_at(BattleHexCoord::new(5, 5), UnitStance::Formed));
        own_army.formations.push(own_formation);

        let mut enemy_army = Army::new(ArmyId::new(), EntityId::new());
        let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());
        enemy_formation.units.push(create_test_unit_at(BattleHexCoord::new(10, 5), UnitStance::Formed));
        enemy_army.formations.push(enemy_formation);

        let visibility = ArmyVisibility::new();
        let mut events = BattleEventLog::new();

        // First tick should evaluate
        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 0, true);
        let orders1 = commander.process_tick(&context, 0, &mut events);
        assert!(!orders1.is_empty());

        // Tick 5 should not evaluate (interval is 10)
        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 5, true);
        let orders2 = commander.process_tick(&context, 5, &mut events);
        assert!(orders2.is_empty());

        // Tick 10 should evaluate
        commander.pending_orders.clear(); // Clear pending for re-test
        let context = DecisionContext::new(&own_army, &enemy_army, &visibility, 10, true);
        let orders3 = commander.process_tick(&context, 10, &mut events);
        assert!(!orders3.is_empty());
    }
}
```

**Step 4: Update mod.rs exports**

```rust
mod commander;
pub use commander::AiCommander;
```

**Step 5: Run tests**

Run: `cargo test --lib battle::ai::commander`
Expected: PASS

**Step 6: Commit**

```bash
git add src/battle/ai/commander.rs
git commit -m "feat(battle): add AiCommander with tactical decision-making"
```

---

## Task 6: Integration with Battle Execution Loop

**Files:**
- Modify: `src/battle/execution.rs`

**Step 1: Write the failing integration test**

Add to `tests/battle_integration.rs`:

```rust
#[test]
fn test_ai_controlled_army_issues_orders() {
    use arc_citadel::battle::ai::{AiCommander, AiPersonality};
    use arc_citadel::battle::battle_map::BattleMap;
    use arc_citadel::battle::execution::BattleState;
    use arc_citadel::battle::hex::BattleHexCoord;
    use arc_citadel::battle::unit_type::UnitType;
    use arc_citadel::battle::units::{
        Army, ArmyId, BattleFormation, BattleUnit, Element, FormationId, UnitId, UnitStance,
    };
    use arc_citadel::core::types::EntityId;

    let map = BattleMap::new(30, 30);

    // Friendly army (player-controlled)
    let mut friendly = Army::new(ArmyId::new(), EntityId::new());
    let mut friendly_formation = BattleFormation::new(FormationId::new(), EntityId::new());
    let mut friendly_unit = BattleUnit::new(UnitId::new(), UnitType::Infantry);
    friendly_unit.elements.push(Element::new(vec![EntityId::new(); 50]));
    friendly_unit.position = BattleHexCoord::new(5, 5);
    friendly_formation.units.push(friendly_unit);
    friendly.formations.push(friendly_formation);

    // Enemy army (AI-controlled)
    let mut enemy = Army::new(ArmyId::new(), EntityId::new());
    enemy.hq_position = BattleHexCoord::new(25, 25);
    enemy.courier_pool = vec![EntityId::new(); 5]; // Give couriers
    let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());
    let mut enemy_unit = BattleUnit::new(UnitId::new(), UnitType::Infantry);
    enemy_unit.elements.push(Element::new(vec![EntityId::new(); 50]));
    enemy_unit.position = BattleHexCoord::new(20, 20);
    enemy_unit.stance = UnitStance::Formed;
    enemy_formation.units.push(enemy_unit);
    enemy.formations.push(enemy_formation);

    let mut state = BattleState::new(map, friendly, enemy);

    // Set up AI controller
    let mut personality = AiPersonality::default();
    personality.behavior.aggression = 0.8;
    personality.preferences.re_evaluation_interval = 1;
    let ai = AiCommander::new(personality);
    state.set_enemy_ai(Some(Box::new(ai)));

    state.start_battle();

    // Run several ticks
    for _ in 0..15 {
        state.run_tick();
    }

    // AI should have dispatched orders via courier
    assert!(
        state.courier_system.delivered.len() > 0 || state.courier_system.in_flight.len() > 0,
        "AI should have issued orders"
    );
}
```

**Step 2: Run test to verify it fails**

Run: `cargo test --test battle_integration test_ai_controlled_army_issues_orders`
Expected: FAIL - `set_enemy_ai` doesn't exist

**Step 3: Add AI controller to BattleState**

In `src/battle/execution.rs`, add:

```rust
// At top of file, add import
use crate::battle::ai::{AiCommander, BattleAI, DecisionContext};

// In BattleState struct, add field after battle_log
pub struct BattleState {
    // ... existing fields ...

    /// Enemy AI controller (None = player controlled)
    #[serde(skip)]
    pub enemy_ai: Option<Box<dyn BattleAI>>,
}

// In BattleState::new(), initialize:
impl BattleState {
    pub fn new(map: BattleMap, friendly_army: Army, enemy_army: Army) -> Self {
        Self {
            // ... existing fields ...
            enemy_ai: None,
        }
    }

    /// Set the enemy AI controller
    pub fn set_enemy_ai(&mut self, ai: Option<Box<dyn BattleAI>>) {
        self.enemy_ai = ai;
    }
```

**Step 4: Add phase_ai() to run_tick()**

In `run_tick()`, add AI phase before pre_tick:

```rust
pub fn run_tick(&mut self) -> BattleEventLog {
    let mut events = BattleEventLog::new();

    if self.is_finished() {
        return events;
    }

    // ===== PHASE 0: AI DECISIONS =====
    self.phase_ai(&mut events);

    // ===== PHASE 1: PRE-TICK =====
    self.phase_pre_tick(&mut events);

    // ... rest unchanged ...
}
```

**Step 5: Implement phase_ai()**

```rust
fn phase_ai(&mut self, events: &mut BattleEventLog) {
    // Skip if no AI controller
    let ai = match &mut self.enemy_ai {
        Some(ai) => ai,
        None => return,
    };

    // Build decision context for enemy army
    let context = DecisionContext::new(
        &self.enemy_army,
        &self.friendly_army,
        &self.enemy_visibility,
        self.tick,
        ai.ignores_fog_of_war(),
    );

    // Get AI decisions
    let orders = ai.process_tick(&context, self.tick, events);

    // Dispatch orders via courier system
    for order in orders {
        // Get destination based on order target
        let destination = match &order.target {
            crate::battle::courier::OrderTarget::Unit(unit_id) => {
                self.enemy_army.get_unit(*unit_id).map(|u| u.position)
            }
            crate::battle::courier::OrderTarget::Formation(formation_id) => {
                self.enemy_army
                    .formations
                    .iter()
                    .find(|f| f.id == *formation_id)
                    .and_then(|f| f.commander_position())
            }
        };

        if let Some(dest) = destination {
            // Get courier from pool
            if let Some(courier_entity) = self.enemy_army.courier_pool.pop() {
                let source = self.enemy_army.hq_position;
                self.courier_system.dispatch(courier_entity, order, source, dest);
            }
        }
    }
}
```

**Step 6: Run integration test**

Run: `cargo test --test battle_integration test_ai_controlled_army_issues_orders`
Expected: PASS

**Step 7: Commit**

```bash
git add src/battle/execution.rs tests/battle_integration.rs
git commit -m "feat(battle): integrate AI controller into battle execution loop"
```

---

## Task 7: Additional Personality Presets

**Files:**
- Create: `data/ai_personalities/cautious.toml`
- Create: `data/ai_personalities/cunning.toml`
- Create: `data/ai_personalities/easy.toml`
- Create: `data/ai_personalities/hard.toml`

**Step 1: Create cautious.toml**

```toml
# data/ai_personalities/cautious.toml
# Cautious commander - prioritizes defense, conserves forces

[behavior]
aggression = 0.2
caution = 0.9
initiative = 0.3
cunning = 0.5

[weights]
attack_value = 0.6
defense_value = 1.5
flanking_value = 1.0
reserve_value = 1.2
retreat_threshold = 0.5
casualty_threshold = 0.3

[preferences]
preferred_range = "ranged"
reserve_usage = "conservative"
re_evaluation_interval = 15

[difficulty]
ignores_fog_of_war = false
reaction_delay = 3
mistake_chance = 0.1
```

**Step 2: Create cunning.toml**

```toml
# data/ai_personalities/cunning.toml
# Cunning commander - uses deception, flanking, exploits weaknesses

[behavior]
aggression = 0.5
caution = 0.5
initiative = 0.7
cunning = 0.9

[weights]
attack_value = 1.0
defense_value = 0.8
flanking_value = 2.0
reserve_value = 0.9
retreat_threshold = 0.35
casualty_threshold = 0.45

[preferences]
preferred_range = "medium"
reserve_usage = "opportunistic"
re_evaluation_interval = 5

[difficulty]
ignores_fog_of_war = false
reaction_delay = 1
mistake_chance = 0.05
```

**Step 3: Create easy.toml (difficulty preset)**

```toml
# data/ai_personalities/easy.toml
# Easy difficulty - slow reactions, makes mistakes

[behavior]
aggression = 0.4
caution = 0.6
initiative = 0.3
cunning = 0.1

[weights]
attack_value = 0.8
defense_value = 1.0
flanking_value = 0.5
reserve_value = 0.5
retreat_threshold = 0.4
casualty_threshold = 0.4

[preferences]
preferred_range = "medium"
reserve_usage = "conservative"
re_evaluation_interval = 20

[difficulty]
ignores_fog_of_war = false
reaction_delay = 5
mistake_chance = 0.3
```

**Step 4: Create hard.toml (difficulty preset)**

```toml
# data/ai_personalities/hard.toml
# Hard difficulty - fast reactions, rarely makes mistakes, sees through fog

[behavior]
aggression = 0.6
caution = 0.4
initiative = 0.8
cunning = 0.7

[weights]
attack_value = 1.3
defense_value = 1.1
flanking_value = 1.5
reserve_value = 0.7
retreat_threshold = 0.25
casualty_threshold = 0.6

[preferences]
preferred_range = "close"
reserve_usage = "aggressive"
re_evaluation_interval = 3

[difficulty]
ignores_fog_of_war = true
reaction_delay = 0
mistake_chance = 0.02
```

**Step 5: Add test for loading all presets**

In `src/battle/ai/personality.rs`, add:

```rust
#[test]
fn test_load_all_presets() {
    let presets = ["default", "aggressive", "cautious", "cunning", "easy", "hard"];
    for name in &presets {
        let result = load_personality(name);
        assert!(result.is_ok(), "Failed to load preset '{}'", name);
    }
}
```

**Step 6: Run test**

Run: `cargo test --lib battle::ai::personality::tests::test_load_all_presets`
Expected: PASS

**Step 7: Commit**

```bash
git add data/ai_personalities/
git commit -m "feat(battle): add personality presets (cautious, cunning, easy, hard)"
```

---

## Task 8: Full Integration Test

**Files:**
- Modify: `tests/battle_integration.rs`

**Step 1: Write comprehensive integration test**

```rust
/// Test a full battle with AI-controlled enemy
#[test]
fn test_full_ai_battle() {
    use arc_citadel::battle::ai::{load_personality, AiCommander};
    use arc_citadel::battle::battle_map::BattleMap;
    use arc_citadel::battle::execution::{BattleOutcome, BattleState};
    use arc_citadel::battle::hex::BattleHexCoord;
    use arc_citadel::battle::unit_type::UnitType;
    use arc_citadel::battle::units::{
        Army, ArmyId, BattleFormation, BattleUnit, Element, FormationId, UnitId, UnitStance,
    };
    use arc_citadel::core::types::EntityId;

    let map = BattleMap::new(40, 40);

    // Setup friendly army
    let mut friendly = Army::new(ArmyId::new(), EntityId::new());
    friendly.hq_position = BattleHexCoord::new(5, 20);
    friendly.courier_pool = vec![EntityId::new(); 10];

    let mut friendly_formation = BattleFormation::new(FormationId::new(), EntityId::new());
    for i in 0..3 {
        let mut unit = BattleUnit::new(UnitId::new(), UnitType::Infantry);
        unit.elements.push(Element::new(vec![EntityId::new(); 80]));
        unit.position = BattleHexCoord::new(10, 15 + i * 3);
        unit.stance = UnitStance::Formed;
        friendly_formation.units.push(unit);
    }
    friendly.formations.push(friendly_formation);

    // Setup enemy army
    let mut enemy = Army::new(ArmyId::new(), EntityId::new());
    enemy.hq_position = BattleHexCoord::new(35, 20);
    enemy.courier_pool = vec![EntityId::new(); 10];

    let mut enemy_formation = BattleFormation::new(FormationId::new(), EntityId::new());
    for i in 0..3 {
        let mut unit = BattleUnit::new(UnitId::new(), UnitType::Infantry);
        unit.elements.push(Element::new(vec![EntityId::new(); 80]));
        unit.position = BattleHexCoord::new(30, 15 + i * 3);
        unit.stance = UnitStance::Formed;
        enemy_formation.units.push(unit);
    }
    enemy.formations.push(enemy_formation);

    let mut state = BattleState::new(map, friendly, enemy);

    // Load aggressive AI personality
    let personality = load_personality("aggressive").expect("Should load aggressive personality");
    let ai = AiCommander::new(personality);
    state.set_enemy_ai(Some(Box::new(ai)));

    state.start_battle();

    // Run battle for up to 500 ticks
    let mut tick_count = 0;
    while !state.is_finished() && tick_count < 500 {
        state.run_tick();
        tick_count += 1;
    }

    // Battle should have progressed
    assert!(tick_count > 10, "Battle should have run for multiple ticks");

    // Should have some combat activity
    let friendly_casualties: u32 = state.friendly_army
        .formations.iter()
        .flat_map(|f| f.units.iter())
        .map(|u| u.casualties)
        .sum();

    let enemy_casualties: u32 = state.enemy_army
        .formations.iter()
        .flat_map(|f| f.units.iter())
        .map(|u| u.casualties)
        .sum();

    assert!(
        friendly_casualties > 0 || enemy_casualties > 0,
        "Combat should have occurred"
    );

    // If battle ended, should have valid outcome
    if state.is_finished() {
        assert!(
            !matches!(state.outcome, BattleOutcome::Undecided),
            "Finished battle should have decided outcome"
        );
    }

    println!("Battle ran for {} ticks", tick_count);
    println!("Friendly casualties: {}", friendly_casualties);
    println!("Enemy casualties: {}", enemy_casualties);
    println!("Outcome: {:?}", state.outcome);
}
```

**Step 2: Run test**

Run: `cargo test --test battle_integration test_full_ai_battle -- --nocapture`
Expected: PASS with battle stats printed

**Step 3: Commit**

```bash
git add tests/battle_integration.rs
git commit -m "test(battle): add comprehensive AI battle integration test"
```

---

## Task 9: Documentation and README

**Files:**
- Create: `src/battle/ai/README.md`

**Step 1: Write module documentation**

```markdown
# Battle AI Module

Enemy AI system for battle decision-making with configurable personalities.

## Architecture

**Trait + Data Hybrid:**
- `trait BattleAI` defines the interface for swappable implementations
- `AiPersonality` struct holds TOML-loaded configuration
- `DecisionContext` provides fog-of-war-filtered battle state
- `PhasePlanManager` handles multi-phase battle plans

## Quick Start

```rust
use arc_citadel::battle::ai::{load_personality, AiCommander};

// Load personality from TOML
let personality = load_personality("aggressive")?;

// Create AI commander
let ai = AiCommander::new(personality);

// Attach to battle state
battle_state.set_enemy_ai(Some(Box::new(ai)));
```

## Personality Configuration

Personalities are TOML files in `data/ai_personalities/`:

```toml
[behavior]
aggression = 0.8  # 0.0 = defensive, 1.0 = aggressive
caution = 0.2     # 0.0 = reckless, 1.0 = cautious
initiative = 0.9  # 0.0 = reactive, 1.0 = proactive
cunning = 0.4     # Tendency to use deception

[weights]
attack_value = 1.5      # Priority for attacking
defense_value = 0.6     # Priority for defending
flanking_value = 1.4    # Priority for flanking
retreat_threshold = 0.15 # Strength ratio to retreat

[difficulty]
ignores_fog_of_war = false  # Cheats vision
reaction_delay = 1          # Ticks before reacting
mistake_chance = 0.15       # Probability of errors
```

## Available Presets

| Preset | Style | Difficulty |
|--------|-------|------------|
| default | Balanced | Medium |
| aggressive | Attacks early | Medium |
| cautious | Defensive | Medium |
| cunning | Flanks, exploits | Medium |
| easy | Slow, mistakes | Easy |
| hard | Fast, precise, cheats | Hard |

## Fog of War

By default, AI respects fog of war via `DecisionContext`:

```rust
// Only sees enemies in visible hexes
let visible_enemies = context.visible_enemy_units();
```

Set `ignores_fog_of_war = true` in difficulty config for cheating AI.

## Phase Plans

AI can have multi-phase battle strategies:

```rust
let mut manager = PhasePlanManager::new();
manager.add_phase(PhasePlan {
    name: "Probe".to_string(),
    reserve_commitment: 0.0,
    aggression_modifier: -0.2,
    transition: PhaseTransition::TimeElapsed(50),
    ..Default::default()
});
manager.add_phase(PhasePlan {
    name: "Main Assault".to_string(),
    reserve_commitment: 0.7,
    aggression_modifier: 0.3,
    transition: PhaseTransition::CasualtiesExceed(0.4),
    ..Default::default()
});
commander.set_phase_manager(manager);
```

## Integration

AI runs in `phase_ai()` before `phase_movement()` in the tick loop:

```
run_tick()
   phase_ai()         AI makes decisions, dispatches couriers
   phase_pre_tick()
   phase_movement()   Couriers advance, orders delivered
   phase_combat()
   phase_morale()
   phase_rout()
   phase_post_tick()
```

## Testing

Run AI tests:
```bash
cargo test --lib battle::ai
cargo test --test battle_integration test_ai
```
```

**Step 2: Commit**

```bash
git add src/battle/ai/README.md
git commit -m "docs(battle): add AI module README"
```

---

## Summary

**Files Created:**
- `src/battle/ai/mod.rs` - Module root with `BattleAI` trait
- `src/battle/ai/personality.rs` - TOML personality loading
- `src/battle/ai/decision_context.rs` - Fog-of-war filtered view
- `src/battle/ai/phase_plans.rs` - Multi-phase battle planning
- `src/battle/ai/commander.rs` - Main AI implementation
- `src/battle/ai/README.md` - Module documentation
- `data/ai_personalities/*.toml` - Personality presets

**Files Modified:**
- `src/battle/mod.rs` - Added `pub mod ai`
- `src/battle/execution.rs` - Added `phase_ai()` and AI integration

**Key Decisions:**
- AI dispatches orders through existing `CourierSystem`
- Fog of war respected via `DecisionContext`
- Seeded RNG for deterministic testing
- Re-evaluation interval prevents order spam
- Phase transitions based on time, strength ratio, or casualties
