# 13-MODULE-SCHEMA-SPEC
> LLM-generated game modules: schema, validation, and hot-loading

## Overview

Arc Citadel supports runtime generation and loading of game modules through LLM interaction. This specification defines the schema for these modules, validation requirements, and the hot-loading system that allows new content to be added without recompilation.

---

## Module Types

### Module Categories

```rust
/// Types of modules that can be generated
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum ModuleType {
    // Content modules
    Item,           // Weapons, armor, tools
    Creature,       // New species/monsters
    Building,       // Constructible structures
    Terrain,        // New terrain types
    Recipe,         // Crafting recipes

    // Behavior modules
    Action,         // New action types
    Skill,          // Learnable skills
    Trait,          // Character traits

    // Story modules
    Event,          // Random events
    Quest,          // Quest chains
    Dialogue,       // Conversation trees

    // System modules
    Faction,        // Political groups
    Culture,        // Cultural definitions
    Religion,       // Belief systems
}
```

---

## Base Module Schema

### Common Fields

```rust
/// Every module shares these base fields
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ModuleHeader {
    /// Unique identifier
    pub id: ModuleId,

    /// Human-readable name
    pub name: String,

    /// Generation metadata
    pub metadata: ModuleMetadata,

    /// Version for compatibility checking
    pub schema_version: u32,

    /// Dependencies on other modules
    pub dependencies: Vec<ModuleId>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ModuleMetadata {
    /// Who/what generated this module
    pub source: ModuleSource,

    /// When it was created
    pub created_at: DateTime<Utc>,

    /// Generation context (if LLM-generated)
    pub generation_context: Option<String>,

    /// Validation status
    pub validated: bool,

    /// Optional tags for categorization
    pub tags: Vec<String>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum ModuleSource {
    /// Built into the game
    Core,

    /// Generated by LLM
    LlmGenerated {
        model: String,
        prompt_hash: String,
    },

    /// User-created
    UserDefined {
        author: String,
    },

    /// Imported from external source
    Imported {
        source_url: String,
    },
}

/// Strongly-typed module ID
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ModuleId {
    pub module_type: ModuleType,
    pub namespace: String,  // e.g., "core", "llm", "user"
    pub name: String,       // e.g., "iron_sword", "goblin"
}

impl ModuleId {
    pub fn as_string(&self) -> String {
        format!("{:?}:{}/{}", self.module_type, self.namespace, self.name)
    }

    pub fn parse(s: &str) -> Result<Self, ModuleError> {
        // Parse "Item:core/iron_sword" format
        let parts: Vec<&str> = s.splitn(2, ':').collect();
        if parts.len() != 2 {
            return Err(ModuleError::InvalidId(s.to_string()));
        }

        let module_type = ModuleType::from_str(parts[0])?;
        let path_parts: Vec<&str> = parts[1].splitn(2, '/').collect();
        if path_parts.len() != 2 {
            return Err(ModuleError::InvalidId(s.to_string()));
        }

        Ok(ModuleId {
            module_type,
            namespace: path_parts[0].to_string(),
            name: path_parts[1].to_string(),
        })
    }
}
```

---

## Item Module Schema

### Weapons

```rust
/// Schema for weapon items
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct WeaponModule {
    pub header: ModuleHeader,

    /// Physical properties (NO percentage modifiers!)
    pub physics: WeaponPhysics,

    /// Visual and descriptive
    pub presentation: ItemPresentation,

    /// Requirements to use
    pub requirements: UseRequirements,

    /// Crafting information
    pub crafting: Option<CraftingInfo>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct WeaponPhysics {
    /// Mass in kg
    pub mass: f32,

    /// Length in meters
    pub length: f32,

    /// Balance point (0.0 = hilt, 1.0 = tip)
    pub balance_point: f32,

    /// Edge geometry for cutting weapons
    pub edge_geometry: Option<EdgeGeometry>,

    /// Material composition
    pub material: MaterialId,

    /// Weapon category for skill matching
    pub category: WeaponCategory,

    /// Grip style
    pub grip: GripStyle,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct EdgeGeometry {
    /// Edge angle in degrees (lower = sharper)
    pub edge_angle: f32,

    /// Edge length in meters
    pub edge_length: f32,

    /// Blade profile
    pub profile: BladeProfile,
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum BladeProfile {
    Flat,       // Even thickness
    Hollow,     // Concave grind (sharp but fragile)
    Convex,     // Axe-like (durable but less sharp)
    Chisel,     // One-sided grind
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum WeaponCategory {
    Sword,
    Axe,
    Mace,
    Spear,
    Polearm,
    Dagger,
    Bow,
    Crossbow,
    Thrown,
    Unarmed,
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum GripStyle {
    OneHanded,
    TwoHanded,
    Versatile,  // Can be used either way
    Paired,     // Meant to be dual-wielded
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ItemPresentation {
    /// Display name
    pub display_name: String,

    /// Description text
    pub description: String,

    /// Visual appearance
    pub appearance: ItemAppearance,

    /// Sound effects
    pub sounds: ItemSounds,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ItemAppearance {
    /// Sprite/model identifier
    pub visual_id: String,

    /// Color tints
    pub tints: Vec<ColorTint>,

    /// Size scale
    pub scale: f32,
}
```

### Armor

```rust
/// Schema for armor items
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ArmorModule {
    pub header: ModuleHeader,
    pub physics: ArmorPhysics,
    pub presentation: ItemPresentation,
    pub requirements: UseRequirements,
    pub crafting: Option<CraftingInfo>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ArmorPhysics {
    /// Material thickness in mm
    pub thickness: f32,

    /// Material type
    pub material: MaterialId,

    /// Body coverage (0.0 - 1.0 per zone)
    pub coverage: BodyCoverage,

    /// Total mass in kg
    pub mass: f32,

    /// Armor slot
    pub slot: ArmorSlot,

    /// Layering info
    pub layer: ArmorLayer,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BodyCoverage {
    pub head: f32,
    pub neck: f32,
    pub torso: f32,
    pub arms: f32,
    pub hands: f32,
    pub groin: f32,
    pub legs: f32,
    pub feet: f32,
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum ArmorSlot {
    Head,
    Body,
    Arms,
    Hands,
    Legs,
    Feet,
    Cloak,
    Shield,
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum ArmorLayer {
    Skin,       // Directly against skin (padding)
    Under,      // Under armor (gambeson)
    Main,       // Primary armor (mail, plate)
    Over,       // Over armor (surcoat)
}
```

---

## Creature Module Schema

```rust
/// Schema for creature/species definitions
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CreatureModule {
    pub header: ModuleHeader,

    /// Physical form
    pub body: BodyDefinition,

    /// Base statistics
    pub base_stats: CreatureStats,

    /// Species-specific values vocabulary
    pub values_schema: ValuesSchema,

    /// Behavioral tendencies
    pub behavior: BehaviorProfile,

    /// Lifecycle
    pub lifecycle: LifecycleInfo,

    /// Social structure
    pub social: SocialStructure,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BodyDefinition {
    /// Body plan (humanoid, quadruped, etc.)
    pub body_plan: BodyPlan,

    /// Size category
    pub size: SizeCategory,

    /// Body parts
    pub parts: Vec<BodyPart>,

    /// Natural weapons
    pub natural_weapons: Vec<NaturalWeapon>,

    /// Natural armor
    pub natural_armor: Option<NaturalArmor>,

    /// Limbs available for tool use
    pub manipulator_limbs: u8,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BodyPart {
    pub name: String,
    pub part_type: BodyPartType,
    pub vital: bool,          // Death if destroyed
    pub hp_fraction: f32,     // Fraction of total HP
    pub parent: Option<String>,
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum BodyPartType {
    Head,
    Torso,
    Arm,
    Hand,
    Leg,
    Foot,
    Tail,
    Wing,
    Tentacle,
    Eye,
    Organ,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct CreatureStats {
    /// Base physical stats
    pub strength: StatRange,
    pub agility: StatRange,
    pub endurance: StatRange,
    pub perception: StatRange,

    /// Base mental stats
    pub intelligence: StatRange,
    pub willpower: StatRange,

    /// Movement
    pub base_speed: f32,      // meters per second
    pub movement_modes: Vec<MovementMode>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct StatRange {
    pub min: f32,
    pub max: f32,
    pub average: f32,
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum MovementMode {
    Walk,
    Run,
    Swim,
    Fly,
    Climb,
    Burrow,
}

/// Species-specific values vocabulary
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ValuesSchema {
    /// List of value concepts for this species
    pub values: Vec<ValueDefinition>,

    /// How values interact with needs
    pub need_value_mapping: Vec<NeedValueMapping>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ValueDefinition {
    /// Internal identifier
    pub id: String,

    /// Display name
    pub name: String,

    /// Description of what this value means
    pub description: String,

    /// What this value opposes (if any)
    pub opposition: Option<String>,

    /// Example behaviors driven by this value
    pub example_behaviors: Vec<String>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct BehaviorProfile {
    /// Activity pattern
    pub activity_cycle: ActivityCycle,

    /// Social tendencies
    pub sociality: Sociality,

    /// Threat response
    pub threat_response: ThreatResponse,

    /// Territory behavior
    pub territoriality: f32,  // 0.0 = nomadic, 1.0 = highly territorial

    /// Diet
    pub diet: Diet,
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum ActivityCycle {
    Diurnal,    // Active during day
    Nocturnal,  // Active at night
    Crepuscular,// Active at dawn/dusk
    Cathemeral, // Active any time
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum Sociality {
    Solitary,
    Pair,
    SmallGroup,
    Pack,
    Herd,
    Colony,
    Eusocial,
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum ThreatResponse {
    Flee,
    Freeze,
    Fight,
    Posture,    // Display/intimidate
    Adaptive,   // Context-dependent
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum Diet {
    Herbivore,
    Carnivore,
    Omnivore,
    Scavenger,
    Filter,      // Filter feeder
    Parasite,
    Photosynthetic,
}
```

---

## Action Module Schema

```rust
/// Schema for action definitions
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ActionModule {
    pub header: ModuleHeader,

    /// What category of action
    pub category: ActionCategory,

    /// Execution properties
    pub execution: ActionExecution,

    /// What needs this satisfies
    pub need_satisfaction: Vec<NeedSatisfaction>,

    /// Requirements to perform
    pub requirements: ActionRequirements,

    /// Effects when completed
    pub effects: Vec<ActionEffect>,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ActionExecution {
    /// Base duration in ticks
    pub base_duration: u32,

    /// Can be interrupted
    pub interruptible: bool,

    /// Cognitive complexity (affects chunking)
    pub complexity: u32,

    /// Physical exertion level
    pub exertion: f32,

    /// Animation/visual key
    pub animation: String,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct NeedSatisfaction {
    pub need: NeedType,
    pub amount: f32,
    pub rate: SatisfactionRate,
}

#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
pub enum SatisfactionRate {
    OnStart,      // Immediate
    OnComplete,   // When action finishes
    PerTick,      // Continuous during action
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ActionRequirements {
    /// Required items in inventory
    pub required_items: Vec<ItemRequirement>,

    /// Required nearby features
    pub required_features: Vec<FeatureRequirement>,

    /// Required skills
    pub required_skills: Vec<SkillRequirement>,

    /// Physical requirements
    pub physical: PhysicalRequirements,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ActionEffect {
    pub effect_type: EffectType,
    pub target: EffectTarget,
    pub magnitude: f32,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum EffectType {
    ModifyNeed(NeedType),
    CreateItem(ModuleId),
    DestroyItem(ModuleId),
    DealDamage(DamageType),
    ApplyCondition(ConditionId),
    ModifyRelation(RelationType),
    SpawnEntity(ModuleId),
    PlaySound(String),
    CreateParticle(String),
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub enum EffectTarget {
    Self_,
    TargetEntity,
    TargetLocation,
    NearbyEntities { radius: f32 },
    AllInFaction,
}
```

---

## Validation System

### Schema Validation

```rust
/// Validates modules against schema requirements
pub struct ModuleValidator {
    /// Known module IDs for dependency checking
    known_modules: HashSet<ModuleId>,

    /// Schema version requirements
    min_schema_version: u32,
    max_schema_version: u32,
}

impl ModuleValidator {
    /// Validate a module, returning errors if invalid
    pub fn validate<M: Module>(&self, module: &M) -> ValidationResult {
        let mut errors = Vec::new();

        // Check schema version
        if module.header().schema_version < self.min_schema_version {
            errors.push(ValidationError::SchemaTooOld {
                found: module.header().schema_version,
                minimum: self.min_schema_version,
            });
        }

        // Check dependencies exist
        for dep in &module.header().dependencies {
            if !self.known_modules.contains(dep) {
                errors.push(ValidationError::MissingDependency {
                    module: module.header().id.clone(),
                    dependency: dep.clone(),
                });
            }
        }

        // Type-specific validation
        errors.extend(module.validate_specific());

        // Balance validation (no percentage modifiers!)
        errors.extend(self.validate_balance(module));

        if errors.is_empty() {
            ValidationResult::Valid
        } else {
            ValidationResult::Invalid(errors)
        }
    }

    /// Ensure module doesn't use forbidden patterns
    fn validate_balance<M: Module>(&self, module: &M) -> Vec<ValidationError> {
        let mut errors = Vec::new();

        // Check for percentage modifiers in any numeric fields
        for (field_name, value) in module.numeric_fields() {
            // Percentage-like values between 0.01 and 2.0 that aren't
            // physical units are suspicious
            if field_name.contains("modifier")
                || field_name.contains("multiplier")
                || field_name.contains("bonus")
                || field_name.contains("reduction")
            {
                errors.push(ValidationError::ForbiddenPattern {
                    module: module.header().id.clone(),
                    field: field_name.clone(),
                    reason: "Percentage modifiers are forbidden. Use physical properties instead.".to_string(),
                });
            }
        }

        errors
    }
}

#[derive(Debug)]
pub enum ValidationResult {
    Valid,
    Invalid(Vec<ValidationError>),
}

#[derive(Debug)]
pub enum ValidationError {
    SchemaTooOld { found: u32, minimum: u32 },
    MissingDependency { module: ModuleId, dependency: ModuleId },
    InvalidField { field: String, reason: String },
    ForbiddenPattern { module: ModuleId, field: String, reason: String },
    PhysicsViolation { field: String, reason: String },
    MissingRequired { field: String },
}
```

### Physics Validation

```rust
/// Ensure physical properties are realistic
pub struct PhysicsValidator;

impl PhysicsValidator {
    pub fn validate_weapon(weapon: &WeaponModule) -> Vec<ValidationError> {
        let mut errors = Vec::new();
        let p = &weapon.physics;

        // Mass bounds (0.1kg to 20kg for hand weapons)
        if p.mass < 0.1 || p.mass > 20.0 {
            errors.push(ValidationError::PhysicsViolation {
                field: "mass".to_string(),
                reason: format!("Weapon mass {} is outside realistic bounds (0.1-20 kg)", p.mass),
            });
        }

        // Length bounds (0.1m to 4m)
        if p.length < 0.1 || p.length > 4.0 {
            errors.push(ValidationError::PhysicsViolation {
                field: "length".to_string(),
                reason: format!("Weapon length {} is outside realistic bounds (0.1-4 m)", p.length),
            });
        }

        // Balance point (must be 0.0-1.0)
        if p.balance_point < 0.0 || p.balance_point > 1.0 {
            errors.push(ValidationError::PhysicsViolation {
                field: "balance_point".to_string(),
                reason: format!("Balance point {} must be between 0.0 and 1.0", p.balance_point),
            });
        }

        // Edge geometry validation
        if let Some(edge) = &p.edge_geometry {
            // Edge angle (5-90 degrees)
            if edge.edge_angle < 5.0 || edge.edge_angle > 90.0 {
                errors.push(ValidationError::PhysicsViolation {
                    field: "edge_angle".to_string(),
                    reason: format!("Edge angle {} is outside realistic bounds (5-90 degrees)", edge.edge_angle),
                });
            }

            // Edge length can't exceed weapon length
            if edge.edge_length > p.length {
                errors.push(ValidationError::PhysicsViolation {
                    field: "edge_length".to_string(),
                    reason: "Edge length cannot exceed weapon length".to_string(),
                });
            }
        }

        errors
    }

    pub fn validate_armor(armor: &ArmorModule) -> Vec<ValidationError> {
        let mut errors = Vec::new();
        let p = &armor.physics;

        // Thickness bounds (0.5mm to 10mm for practical armor)
        if p.thickness < 0.5 || p.thickness > 10.0 {
            errors.push(ValidationError::PhysicsViolation {
                field: "thickness".to_string(),
                reason: format!("Armor thickness {} is outside realistic bounds (0.5-10 mm)", p.thickness),
            });
        }

        // Mass bounds (0.5kg to 40kg for wearable armor)
        if p.mass < 0.5 || p.mass > 40.0 {
            errors.push(ValidationError::PhysicsViolation {
                field: "mass".to_string(),
                reason: format!("Armor mass {} is outside realistic bounds (0.5-40 kg)", p.mass),
            });
        }

        // Coverage values must sum to reasonable total
        let total_coverage = p.coverage.head + p.coverage.torso + p.coverage.arms
            + p.coverage.legs + p.coverage.hands + p.coverage.feet;
        if total_coverage > 6.0 {
            errors.push(ValidationError::PhysicsViolation {
                field: "coverage".to_string(),
                reason: "Total coverage exceeds maximum".to_string(),
            });
        }

        errors
    }
}
```

---

## Hot-Loading System

### Module Registry

```rust
/// Central registry for all loaded modules
pub struct ModuleRegistry {
    /// All loaded modules by type
    weapons: HashMap<ModuleId, WeaponModule>,
    armor: HashMap<ModuleId, ArmorModule>,
    creatures: HashMap<ModuleId, CreatureModule>,
    actions: HashMap<ModuleId, ActionModule>,
    // ... other module types

    /// Load order for dependency resolution
    load_order: Vec<ModuleId>,

    /// File watcher for hot-reload
    watcher: Option<FileWatcher>,

    /// Validation state
    validator: ModuleValidator,
}

impl ModuleRegistry {
    /// Load a module from file
    pub fn load_from_file(&mut self, path: &Path) -> Result<ModuleId, ModuleError> {
        // Read and parse
        let content = std::fs::read_to_string(path)?;
        let raw: RawModule = serde_json::from_str(&content)?;

        // Determine type and deserialize
        let module_id = match raw.header.id.module_type {
            ModuleType::Item => {
                if raw.data.contains_key("edge_geometry") || raw.data.contains_key("grip") {
                    let weapon: WeaponModule = serde_json::from_value(raw.data)?;
                    self.load_weapon(weapon)?
                } else {
                    let armor: ArmorModule = serde_json::from_value(raw.data)?;
                    self.load_armor(armor)?
                }
            },
            ModuleType::Creature => {
                let creature: CreatureModule = serde_json::from_value(raw.data)?;
                self.load_creature(creature)?
            },
            ModuleType::Action => {
                let action: ActionModule = serde_json::from_value(raw.data)?;
                self.load_action(action)?
            },
            _ => return Err(ModuleError::UnsupportedType(raw.header.id.module_type)),
        };

        Ok(module_id)
    }

    /// Load a weapon module
    fn load_weapon(&mut self, weapon: WeaponModule) -> Result<ModuleId, ModuleError> {
        // Validate
        let validation = self.validator.validate(&weapon);
        if let ValidationResult::Invalid(errors) = validation {
            return Err(ModuleError::ValidationFailed(errors));
        }

        // Physics validation
        let physics_errors = PhysicsValidator::validate_weapon(&weapon);
        if !physics_errors.is_empty() {
            return Err(ModuleError::ValidationFailed(physics_errors));
        }

        let id = weapon.header.id.clone();
        self.weapons.insert(id.clone(), weapon);
        self.load_order.push(id.clone());

        Ok(id)
    }

    /// Enable hot-reloading for a directory
    pub fn enable_hot_reload(&mut self, watch_dir: &Path) -> Result<(), ModuleError> {
        let (tx, rx) = std::sync::mpsc::channel();

        let mut watcher = notify::recommended_watcher(move |res: Result<notify::Event, _>| {
            if let Ok(event) = res {
                let _ = tx.send(event);
            }
        })?;

        watcher.watch(watch_dir, notify::RecursiveMode::Recursive)?;

        // Spawn handler thread
        let registry = Arc::new(Mutex::new(self.clone()));
        std::thread::spawn(move || {
            for event in rx {
                if event.kind.is_modify() || event.kind.is_create() {
                    for path in event.paths {
                        if path.extension() == Some(OsStr::new("json")) {
                            if let Ok(mut reg) = registry.lock() {
                                let _ = reg.reload_module(&path);
                            }
                        }
                    }
                }
            }
        });

        Ok(())
    }

    /// Reload a modified module
    fn reload_module(&mut self, path: &Path) -> Result<(), ModuleError> {
        // Find existing module ID from path
        let module_id = self.path_to_id(path)?;

        // Remove old version
        self.unload(&module_id);

        // Load new version
        self.load_from_file(path)?;

        log::info!("Hot-reloaded module: {:?}", module_id);
        Ok(())
    }

    /// Get a weapon by ID
    pub fn get_weapon(&self, id: &ModuleId) -> Option<&WeaponModule> {
        self.weapons.get(id)
    }

    /// Get an armor by ID
    pub fn get_armor(&self, id: &ModuleId) -> Option<&ArmorModule> {
        self.armor.get(id)
    }

    /// Get a creature definition by ID
    pub fn get_creature(&self, id: &ModuleId) -> Option<&CreatureModule> {
        self.creatures.get(id)
    }

    /// List all loaded modules of a type
    pub fn list_modules(&self, module_type: ModuleType) -> Vec<&ModuleId> {
        match module_type {
            ModuleType::Item => {
                self.weapons.keys().chain(self.armor.keys()).collect()
            },
            ModuleType::Creature => self.creatures.keys().collect(),
            ModuleType::Action => self.actions.keys().collect(),
            _ => vec![],
        }
    }
}
```

### Module File Format

```json
{
  "header": {
    "id": {
      "module_type": "Item",
      "namespace": "llm",
      "name": "obsidian_cleaver"
    },
    "name": "Obsidian Cleaver",
    "metadata": {
      "source": {
        "LlmGenerated": {
          "model": "claude-3",
          "prompt_hash": "abc123"
        }
      },
      "created_at": "2026-01-14T12:00:00Z",
      "generation_context": "Player requested a volcanic-themed weapon",
      "validated": true,
      "tags": ["volcanic", "slashing", "exotic"]
    },
    "schema_version": 1,
    "dependencies": ["Item:core/obsidian_material"]
  },
  "data": {
    "physics": {
      "mass": 3.2,
      "length": 0.8,
      "balance_point": 0.65,
      "edge_geometry": {
        "edge_angle": 15.0,
        "edge_length": 0.5,
        "profile": "Chisel"
      },
      "material": "Item:core/obsidian_material",
      "category": "Axe",
      "grip": "TwoHanded"
    },
    "presentation": {
      "display_name": "Obsidian Cleaver",
      "description": "A brutal cleaving weapon with a blade of volcanic glass. Extremely sharp but brittle.",
      "appearance": {
        "visual_id": "weapon_axe_obsidian",
        "tints": [{"r": 20, "g": 20, "b": 30}],
        "scale": 1.0
      },
      "sounds": {
        "swing": "swing_heavy",
        "impact": "glass_crack"
      }
    },
    "requirements": {
      "strength": 12.0,
      "skills": []
    },
    "crafting": {
      "recipe_id": "Recipe:llm/craft_obsidian_cleaver",
      "workstation": "forge",
      "skill": "Smithing",
      "difficulty": 6
    }
  }
}
```

---

## LLM Generation Integration

### Generation Prompts

```rust
/// System for generating modules via LLM
pub struct ModuleGenerator {
    llm_client: LlmClient,
    validator: ModuleValidator,
    registry: Arc<Mutex<ModuleRegistry>>,
}

impl ModuleGenerator {
    /// Generate a new weapon from description
    pub async fn generate_weapon(&self, description: &str) -> Result<WeaponModule, GenerationError> {
        let prompt = format!(
            r#"Generate a weapon module in JSON format for the Arc Citadel game.

CRITICAL RULES:
1. NO percentage modifiers or multipliers
2. All effects must come from physical properties
3. Mass must be 0.1-20 kg
4. Length must be 0.1-4 m
5. Balance point must be 0.0-1.0

Description: {description}

Respond with ONLY valid JSON matching this schema:
{{
  "header": {{ ... }},
  "physics": {{
    "mass": <kg>,
    "length": <meters>,
    "balance_point": <0.0-1.0>,
    "edge_geometry": {{ ... }} or null,
    "material": "<material_id>",
    "category": "<WeaponCategory>",
    "grip": "<GripStyle>"
  }},
  "presentation": {{ ... }},
  "requirements": {{ ... }},
  "crafting": null
}}"#
        );

        let response = self.llm_client.complete(&prompt).await?;
        let weapon: WeaponModule = serde_json::from_str(&response)?;

        // Validate before returning
        let validation = self.validator.validate(&weapon);
        match validation {
            ValidationResult::Valid => Ok(weapon),
            ValidationResult::Invalid(errors) => {
                // Try to fix common issues
                self.attempt_fix_weapon(weapon, errors).await
            }
        }
    }

    /// Attempt to fix validation errors via follow-up prompt
    async fn attempt_fix_weapon(
        &self,
        weapon: WeaponModule,
        errors: Vec<ValidationError>,
    ) -> Result<WeaponModule, GenerationError> {
        let error_desc: Vec<String> = errors.iter().map(|e| format!("{:?}", e)).collect();

        let prompt = format!(
            r#"The generated weapon has validation errors:
{}

Original weapon:
{}

Fix ONLY the issues listed above. Respond with corrected JSON."#,
            error_desc.join("\n"),
            serde_json::to_string_pretty(&weapon)?
        );

        let response = self.llm_client.complete(&prompt).await?;
        let fixed: WeaponModule = serde_json::from_str(&response)?;

        // Validate again
        let validation = self.validator.validate(&fixed);
        match validation {
            ValidationResult::Valid => Ok(fixed),
            ValidationResult::Invalid(e) => Err(GenerationError::ValidationFailed(e)),
        }
    }

    /// Generate creature from description
    pub async fn generate_creature(&self, description: &str) -> Result<CreatureModule, GenerationError> {
        let prompt = format!(
            r#"Generate a creature/species module for Arc Citadel.

CRITICAL RULES:
1. Species must have unique values vocabulary (not human values!)
2. Physical stats use ranges (min, max, average)
3. Body parts must form valid hierarchy
4. Behavior must be internally consistent

Description: {description}

Include:
- Unique species-specific values (NOT: honor, beauty, comfort - those are HUMAN values)
- Realistic body plan
- Behavioral tendencies
- Lifecycle information

Respond with ONLY valid JSON."#
        );

        let response = self.llm_client.complete(&prompt).await?;
        let creature: CreatureModule = serde_json::from_str(&response)?;

        // Validate
        let validation = self.validator.validate(&creature);
        match validation {
            ValidationResult::Valid => Ok(creature),
            ValidationResult::Invalid(errors) => Err(GenerationError::ValidationFailed(errors)),
        }
    }
}

#[derive(Debug)]
pub enum GenerationError {
    LlmError(LlmError),
    ParseError(serde_json::Error),
    ValidationFailed(Vec<ValidationError>),
}
```

---

## Related Specifications

| Document | Relationship |
|----------|--------------|
| [04-LLM-INTERFACE-SPEC](04-LLM-INTERFACE-SPEC.md) | LLM client for generation |
| [06-BALANCE-COMPOSITION-SPEC](06-BALANCE-COMPOSITION-SPEC.md) | Validation rules |
| [08-GENETICS-SYSTEM-SPEC](08-GENETICS-SYSTEM-SPEC.md) | Creature values system |
| [11-ACTION-CATALOG.md](11-ACTION-CATALOG.md) | Base action definitions |
| [14-PHYSICS-COMBAT-SPEC](14-PHYSICS-COMBAT-SPEC.md) | Physics validation bounds |

---

## Changelog

| Date | Change |
|------|--------|
| 2026-01-14 | Initial specification created |
