# 14-PHYSICS-COMBAT-SPEC
> Detailed physics formulas for combat resolution

## Overview

This specification defines the physics-based combat system for Arc Citadel. All combat effects emerge from the interaction of physical properties—mass, velocity, material hardness, body structure—rather than percentage modifiers or abstract damage numbers.

---

## Core Principles

### The Physics Pipeline

```
Attack Initiation
    │
    ▼
Force Generation (strength × weapon physics)
    │
    ▼
Impact Calculation (momentum × geometry)
    │
    ▼
Armor Interaction (penetration probability)
    │
    ▼
Wound Generation (force vs tissue)
    │
    ▼
Effect Resolution (bleeding, pain, incapacitation)
```

### Forbidden Patterns

```rust
// ❌ NEVER DO THIS
let damage = base_damage * weapon_bonus * strength_modifier * skill_bonus;
let blocked = damage * (1.0 - armor.reduction);

// ✅ ALWAYS DO THIS
let force = calculate_impact_force(weapon, wielder, swing_type);
let penetration = armor_penetration_probability(force, armor);
let wound = if penetrated { generate_wound(force, target_tissue) } else { None };
```

---

## Force Generation

### Swing Mechanics

```rust
/// Calculate the force generated by a melee attack
pub fn calculate_swing_force(
    weapon: &WeaponPhysics,
    wielder: &CombatantStats,
    swing_type: SwingType,
    fatigue: f32,
) -> SwingResult {
    // Moment of inertia of the weapon
    // I = m * r² where r is distance from grip to balance point
    let grip_to_balance = weapon.length * weapon.balance_point;
    let moment_of_inertia = weapon.mass * grip_to_balance.powi(2);

    // Maximum angular acceleration based on strength
    // τ = I * α, so α = τ / I
    // Torque from strength applied at grip
    let max_torque = wielder.strength * 10.0;  // N⋅m (strength in abstract units)
    let max_angular_accel = max_torque / moment_of_inertia;

    // Swing arc depends on swing type
    let swing_arc = match swing_type {
        SwingType::Overhead => 2.5,    // radians (~143°)
        SwingType::Horizontal => 2.0,  // radians (~115°)
        SwingType::Thrust => 0.0,      // Linear motion
        SwingType::Backhand => 1.5,    // radians (~86°)
        SwingType::Pommel => 0.3,      // Short arc
    };

    // Time to complete swing (simplified kinematics)
    // θ = ½αt², so t = √(2θ/α)
    let swing_time = if swing_arc > 0.0 {
        (2.0 * swing_arc / max_angular_accel).sqrt()
    } else {
        // Thrust uses linear motion
        0.3  // Base thrust time
    };

    // Final angular velocity: ω = αt
    let angular_velocity = max_angular_accel * swing_time;

    // Skill affects how efficiently the swing is executed
    let skill_efficiency = calculate_skill_efficiency(wielder.skill_level);

    // Fatigue reduces force output exponentially
    let fatigue_factor = (-2.0 * fatigue).exp();

    // Actual angular velocity achieved
    let effective_angular_velocity = angular_velocity * skill_efficiency * fatigue_factor;

    // Linear velocity at weapon tip
    let tip_distance = weapon.length * (1.0 - weapon.balance_point);
    let tip_velocity = effective_angular_velocity * tip_distance;

    // For thrusts, velocity is different
    let impact_velocity = match swing_type {
        SwingType::Thrust => {
            // Thrust velocity from arm extension + body weight
            let thrust_force = wielder.strength * 8.0 * fatigue_factor;
            let acceleration = thrust_force / weapon.mass;
            // v² = 2as, assume 0.5m extension
            (2.0 * acceleration * 0.5).sqrt()
        },
        _ => tip_velocity,
    };

    SwingResult {
        impact_velocity,
        swing_time,
        momentum: weapon.mass * impact_velocity,
        kinetic_energy: 0.5 * weapon.mass * impact_velocity.powi(2),
    }
}

#[derive(Debug)]
pub struct SwingResult {
    pub impact_velocity: f32,  // m/s
    pub swing_time: f32,       // seconds
    pub momentum: f32,         // kg⋅m/s
    pub kinetic_energy: f32,   // joules
}

/// Skill affects execution efficiency
fn calculate_skill_efficiency(skill_level: u8) -> f32 {
    // Novice achieves 30% of theoretical maximum
    // Master achieves 95%
    let base = 0.3;
    let per_level = 0.065;
    (base + skill_level as f32 * per_level).min(0.95)
}
```

### Impact Force

```rust
/// Calculate the actual force delivered on impact
pub fn calculate_impact_force(
    swing: &SwingResult,
    weapon: &WeaponPhysics,
    impact_type: ImpactType,
) -> ImpactForce {
    // Contact time affects force (F = Δp / Δt)
    // Shorter contact time = higher force
    let contact_time = match impact_type {
        ImpactType::Slash => 0.01,      // Very brief edge contact
        ImpactType::Chop => 0.02,       // Slightly longer
        ImpactType::Thrust => 0.005,    // Point contact, very brief
        ImpactType::Blunt => 0.05,      // Longer contact, force spread
        ImpactType::Pommel => 0.03,     // Short blunt impact
    };

    // Force from momentum change
    let raw_force = swing.momentum / contact_time;

    // Contact area affects pressure (force concentration)
    let contact_area = match impact_type {
        ImpactType::Slash | ImpactType::Chop => {
            // Edge geometry determines contact area
            if let Some(edge) = &weapon.edge_geometry {
                // Thinner edge = smaller area = more pressure
                let edge_width = edge.edge_angle.to_radians().tan() * 0.001;  // mm to m
                edge.edge_length * edge_width
            } else {
                0.001  // Default 1cm² for bladeless weapons
            }
        },
        ImpactType::Thrust => {
            // Point contact
            0.0001  // 1cm² point
        },
        ImpactType::Blunt | ImpactType::Pommel => {
            // Spread over larger area
            0.005  // 5cm²
        },
    };

    // Pressure = Force / Area
    let pressure = raw_force / contact_area;

    ImpactForce {
        force_newtons: raw_force,
        pressure_pascals: pressure,
        contact_area,
        contact_time,
        energy_delivered: swing.kinetic_energy * 0.8,  // 80% energy transfer
    }
}

#[derive(Debug)]
pub struct ImpactForce {
    pub force_newtons: f32,
    pub pressure_pascals: f32,
    pub contact_area: f32,
    pub contact_time: f32,
    pub energy_delivered: f32,
}

#[derive(Clone, Copy, Debug)]
pub enum ImpactType {
    Slash,   // Drawing cut
    Chop,    // Percussive cut
    Thrust,  // Point penetration
    Blunt,   // Crushing impact
    Pommel,  // Pommel strike
}
```

---

## Armor Penetration

### Penetration Probability

```rust
/// Determine if an attack penetrates armor
pub fn penetration_check(
    impact: &ImpactForce,
    armor: &ArmorPhysics,
    hit_location: BodyZone,
) -> PenetrationResult {
    // First check if this location is covered
    let coverage = armor.coverage.get(hit_location);
    if rand::random::<f32>() > coverage {
        return PenetrationResult::NotCovered;
    }

    // Calculate effective armor resistance
    let effective_thickness = calculate_effective_thickness(armor, hit_location);

    // Material hardness affects penetration resistance
    let material_hardness = armor.material.hardness();

    // Armor resistance (simplified model)
    // Higher = harder to penetrate
    let armor_resistance = effective_thickness * material_hardness * 1_000_000.0;  // Pa

    // Penetration occurs when pressure exceeds resistance
    // Use sigmoid for probabilistic transition
    let ratio = impact.pressure_pascals / armor_resistance;
    let steepness = 8.0;
    let penetration_probability = 1.0 / (1.0 + (-steepness * (ratio - 1.0)).exp());

    let roll = rand::random::<f32>();

    if roll < penetration_probability {
        // Penetration - calculate remaining force
        let energy_absorbed = impact.energy_delivered * armor.material.absorption();
        let remaining_energy = impact.energy_delivered - energy_absorbed;

        PenetrationResult::Penetrated {
            remaining_force: (2.0 * remaining_energy / 0.001).sqrt(),  // F from E = ½mv²
            penetration_depth: calculate_penetration_depth(impact, armor),
        }
    } else {
        // Blocked - but blunt force transfers
        let blunt_transfer = impact.force_newtons * armor.material.blunt_transfer();

        PenetrationResult::Blocked {
            blunt_force: blunt_transfer,
            armor_damage: calculate_armor_damage(impact, armor),
        }
    }
}

fn calculate_effective_thickness(armor: &ArmorPhysics, location: BodyZone) -> f32 {
    let base_thickness = armor.thickness;

    // Condition reduces effectiveness
    let condition_factor = armor.condition;

    // Some locations have layered protection
    let layer_factor = match location {
        BodyZone::Torso => 1.2,   // Often extra padding
        BodyZone::Head => 1.1,   // Thick construction
        BodyZone::Groin => 0.8,  // Thinner for mobility
        BodyZone::Joints => 0.6, // Gaps in armor
        _ => 1.0,
    };

    base_thickness * condition_factor * layer_factor / 1000.0  // Convert mm to m
}

fn calculate_penetration_depth(impact: &ImpactForce, armor: &ArmorPhysics) -> f32 {
    // Simplified penetration depth calculation
    // Based on pressure vs material resistance
    let material_resistance = armor.material.hardness() * 1e9;  // GPa to Pa
    let depth = impact.pressure_pascals / material_resistance * 0.01;  // Scale to reasonable depth
    depth.min(0.1)  // Cap at 10cm
}

fn calculate_armor_damage(impact: &ImpactForce, armor: &ArmorPhysics) -> f32 {
    // Armor takes damage from blocked hits
    let material_toughness = armor.material.toughness();
    let damage_threshold = material_toughness * 10000.0;  // N threshold

    if impact.force_newtons > damage_threshold {
        (impact.force_newtons - damage_threshold) / damage_threshold * 0.01
    } else {
        0.0
    }
}

#[derive(Debug)]
pub enum PenetrationResult {
    NotCovered,
    Penetrated {
        remaining_force: f32,
        penetration_depth: f32,
    },
    Blocked {
        blunt_force: f32,
        armor_damage: f32,
    },
}
```

### Material Properties

```rust
/// Material properties for combat calculations
#[derive(Clone, Copy, Debug)]
pub struct Material {
    pub density: f32,       // kg/m³
    pub hardness: f32,      // 0.0-1.0 (Mohs-like scale, normalized)
    pub toughness: f32,     // 0.0-1.0 (fracture resistance)
    pub elasticity: f32,    // 0.0-1.0 (deformation recovery)
}

impl Material {
    /// Iron: workable but not exceptional
    pub const IRON: Material = Material {
        density: 7874.0,
        hardness: 0.4,
        toughness: 0.6,
        elasticity: 0.3,
    };

    /// Steel: good all-around
    pub const STEEL: Material = Material {
        density: 7850.0,
        hardness: 0.7,
        toughness: 0.7,
        elasticity: 0.4,
    };

    /// Hardened steel: maximum hardness
    pub const HARDENED_STEEL: Material = Material {
        density: 7850.0,
        hardness: 0.9,
        toughness: 0.5,  // More brittle
        elasticity: 0.2,
    };

    /// Bronze: heavy but serviceable
    pub const BRONZE: Material = Material {
        density: 8800.0,
        hardness: 0.35,
        toughness: 0.5,
        elasticity: 0.35,
    };

    /// Leather: flexible protection
    pub const LEATHER: Material = Material {
        density: 860.0,
        hardness: 0.1,
        toughness: 0.8,
        elasticity: 0.7,
    };

    /// Bone: natural armor
    pub const BONE: Material = Material {
        density: 1900.0,
        hardness: 0.3,
        toughness: 0.4,
        elasticity: 0.1,
    };

    /// How much energy is absorbed on impact
    pub fn absorption(&self) -> f32 {
        // Tough materials absorb more
        self.toughness * 0.3 + self.elasticity * 0.2
    }

    /// How much force transfers through as blunt trauma
    pub fn blunt_transfer(&self) -> f32 {
        // Hard materials transfer more blunt force
        // Elastic materials absorb impact
        (1.0 - self.elasticity) * 0.5 + self.hardness * 0.3
    }
}
```

---

## Wound System

### Wound Generation

```rust
/// Generate a wound based on impact
pub fn generate_wound(
    impact: &ImpactForce,
    penetration: &PenetrationResult,
    target_location: BodyZone,
    target_tissue: &TissueProperties,
) -> Option<Wound> {
    match penetration {
        PenetrationResult::NotCovered => {
            // Direct hit to unarmored location
            Some(calculate_direct_wound(impact, target_location, target_tissue))
        },
        PenetrationResult::Penetrated { remaining_force, penetration_depth } => {
            // Penetrating wound
            Some(calculate_penetrating_wound(
                *remaining_force,
                *penetration_depth,
                target_location,
                target_tissue,
            ))
        },
        PenetrationResult::Blocked { blunt_force, .. } => {
            // Only blunt trauma
            calculate_blunt_trauma(*blunt_force, target_location, target_tissue)
        },
    }
}

fn calculate_direct_wound(
    impact: &ImpactForce,
    location: BodyZone,
    tissue: &TissueProperties,
) -> Wound {
    // Determine wound type based on impact characteristics
    let wound_type = if impact.contact_area < 0.0005 {
        // Small contact area = cutting/piercing
        if impact.pressure_pascals > tissue.cut_threshold() {
            WoundType::Laceration
        } else {
            WoundType::Bruise
        }
    } else {
        // Large contact area = blunt
        WoundType::Contusion
    };

    // Wound severity based on force vs tissue resistance
    let severity = calculate_severity(impact.force_newtons, tissue, &wound_type);

    // Calculate bleeding rate based on wound type and location
    let bleeding = calculate_bleeding_rate(&wound_type, severity, location);

    // Pain is proportional to force and nerve density
    let pain = impact.force_newtons / 1000.0 * location.nerve_density();

    Wound {
        wound_type,
        location,
        severity,
        bleeding_rate: bleeding,
        pain_level: pain.min(1.0),
        is_infected: false,
        healing_progress: 0.0,
    }
}

fn calculate_penetrating_wound(
    remaining_force: f32,
    penetration_depth: f32,
    location: BodyZone,
    tissue: &TissueProperties,
) -> Wound {
    // Deep wounds are more severe
    let depth_severity = (penetration_depth * 20.0).min(1.0);

    // Check for vital structures
    let vital_hit = location.has_vitals() && penetration_depth > 0.03;

    let wound_type = if vital_hit {
        WoundType::VitalPuncture
    } else if penetration_depth > 0.05 {
        WoundType::DeepPuncture
    } else {
        WoundType::Puncture
    };

    let severity = depth_severity * (remaining_force / 5000.0).min(1.0);

    Wound {
        wound_type,
        location,
        severity: severity.min(1.0),
        bleeding_rate: calculate_bleeding_rate(&wound_type, severity, location),
        pain_level: (remaining_force / 2000.0).min(1.0),
        is_infected: false,
        healing_progress: 0.0,
    }
}

fn calculate_blunt_trauma(
    blunt_force: f32,
    location: BodyZone,
    tissue: &TissueProperties,
) -> Option<Wound> {
    // Threshold for bruising
    let bruise_threshold = tissue.bruise_threshold();

    if blunt_force < bruise_threshold {
        return None;  // No wound
    }

    let severity = ((blunt_force - bruise_threshold) / bruise_threshold * 0.3).min(0.8);

    // Check for bone breaks at high force
    let wound_type = if blunt_force > tissue.fracture_threshold() {
        WoundType::Fracture
    } else if blunt_force > bruise_threshold * 3.0 {
        WoundType::Contusion
    } else {
        WoundType::Bruise
    };

    Some(Wound {
        wound_type,
        location,
        severity,
        bleeding_rate: 0.0,  // Internal bleeding handled separately
        pain_level: (blunt_force / 3000.0).min(1.0),
        is_infected: false,
        healing_progress: 0.0,
    })
}

fn calculate_severity(force: f32, tissue: &TissueProperties, wound_type: &WoundType) -> f32 {
    let resistance = match wound_type {
        WoundType::Laceration => tissue.cut_resistance(),
        WoundType::Puncture | WoundType::DeepPuncture | WoundType::VitalPuncture => {
            tissue.puncture_resistance()
        },
        WoundType::Contusion | WoundType::Bruise => tissue.blunt_resistance(),
        WoundType::Fracture => tissue.fracture_threshold(),
    };

    (force / resistance * 0.5).min(1.0)
}

fn calculate_bleeding_rate(wound_type: &WoundType, severity: f32, location: BodyZone) -> f32 {
    let base_rate = match wound_type {
        WoundType::Laceration => 0.05,       // ml/s per severity
        WoundType::Puncture => 0.02,
        WoundType::DeepPuncture => 0.08,
        WoundType::VitalPuncture => 0.2,     // Arterial bleeding
        WoundType::Contusion => 0.01,        // Internal
        WoundType::Bruise => 0.0,
        WoundType::Fracture => 0.03,         // Internal bleeding
    };

    // Location affects bleeding (vascularity)
    let location_multiplier = location.vascularity();

    base_rate * severity * location_multiplier
}

#[derive(Clone, Debug)]
pub struct Wound {
    pub wound_type: WoundType,
    pub location: BodyZone,
    pub severity: f32,          // 0.0-1.0
    pub bleeding_rate: f32,     // ml/s
    pub pain_level: f32,        // 0.0-1.0
    pub is_infected: bool,
    pub healing_progress: f32,  // 0.0-1.0
}

#[derive(Clone, Copy, Debug)]
pub enum WoundType {
    Bruise,         // Surface trauma
    Contusion,      // Deep bruising
    Laceration,     // Cutting wound
    Puncture,       // Shallow piercing
    DeepPuncture,   // Deep piercing
    VitalPuncture,  // Hit vital organ/artery
    Fracture,       // Broken bone
}
```

### Tissue Properties

```rust
/// Properties of body tissue for wound calculation
#[derive(Clone, Debug)]
pub struct TissueProperties {
    pub tissue_type: TissueType,
    pub density: f32,
    pub elasticity: f32,
}

#[derive(Clone, Copy, Debug)]
pub enum TissueType {
    Skin,
    Muscle,
    Fat,
    Bone,
    Organ,
    Nerve,
    Artery,
}

impl TissueProperties {
    /// Pressure needed to cut through
    pub fn cut_threshold(&self) -> f32 {
        match self.tissue_type {
            TissueType::Skin => 100_000.0,      // 100 kPa
            TissueType::Muscle => 200_000.0,
            TissueType::Fat => 50_000.0,
            TissueType::Bone => 1_000_000.0,    // 1 MPa
            TissueType::Organ => 80_000.0,
            TissueType::Nerve => 30_000.0,
            TissueType::Artery => 60_000.0,
        }
    }

    pub fn cut_resistance(&self) -> f32 {
        self.cut_threshold() * 50.0  // Convert to force equivalent
    }

    pub fn puncture_resistance(&self) -> f32 {
        self.cut_resistance() * 0.7  // Easier to puncture than cut
    }

    pub fn blunt_resistance(&self) -> f32 {
        match self.tissue_type {
            TissueType::Bone => 8000.0,
            TissueType::Muscle => 3000.0,
            TissueType::Fat => 1000.0,
            TissueType::Organ => 500.0,
            _ => 2000.0,
        }
    }

    pub fn bruise_threshold(&self) -> f32 {
        self.blunt_resistance() * 0.5
    }

    pub fn fracture_threshold(&self) -> f32 {
        match self.tissue_type {
            TissueType::Bone => 15000.0,
            _ => f32::INFINITY,  // Can't fracture non-bone
        }
    }
}
```

### Body Zones

```rust
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum BodyZone {
    Head,
    Face,
    Neck,
    Torso,
    UpperArm,
    Forearm,
    Hand,
    Groin,
    Thigh,
    Shin,
    Foot,
}

impl BodyZone {
    /// How many nerves = how much pain
    pub fn nerve_density(&self) -> f32 {
        match self {
            Self::Face => 1.5,
            Self::Hand => 1.4,
            Self::Groin => 1.3,
            Self::Neck => 1.2,
            Self::Head => 1.0,
            Self::Foot => 0.9,
            _ => 0.8,
        }
    }

    /// How vascular = how much bleeding
    pub fn vascularity(&self) -> f32 {
        match self {
            Self::Neck => 2.0,    // Carotid
            Self::Groin => 1.8,   // Femoral
            Self::Head => 1.5,
            Self::Torso => 1.3,
            Self::Thigh => 1.2,
            _ => 1.0,
        }
    }

    /// Does this zone contain vital structures
    pub fn has_vitals(&self) -> bool {
        matches!(self, Self::Head | Self::Neck | Self::Torso | Self::Groin)
    }

    /// Hit probability weight (larger targets easier to hit)
    pub fn hit_weight(&self) -> f32 {
        match self {
            Self::Torso => 0.35,
            Self::Thigh => 0.12,
            Self::UpperArm => 0.08,
            Self::Shin => 0.08,
            Self::Forearm => 0.06,
            Self::Head => 0.08,
            Self::Hand => 0.04,
            Self::Foot => 0.04,
            Self::Groin => 0.05,
            Self::Face => 0.05,
            Self::Neck => 0.05,
        }
    }
}
```

---

## Combat Effects

### Pain and Shock

```rust
/// Track pain and shock state
#[derive(Clone, Debug)]
pub struct PainState {
    /// Current pain level (0.0-1.0)
    pub pain: f32,

    /// Shock state (0.0-1.0, 1.0 = unconscious)
    pub shock: f32,

    /// Pain tolerance (from stats/traits)
    pub tolerance: f32,
}

impl PainState {
    /// Apply pain from a wound
    pub fn apply_wound_pain(&mut self, wound: &Wound) {
        let pain_input = wound.pain_level * (1.0 - self.tolerance * 0.5);

        // Pain accumulates with diminishing returns
        self.pain = 1.0 - (1.0 - self.pain) * (1.0 - pain_input);
    }

    /// Calculate combat effectiveness reduction from pain
    pub fn combat_penalty(&self) -> f32 {
        // Exponential degradation
        (-3.0 * self.pain).exp()
    }

    /// Check for pain-induced incapacitation
    pub fn is_incapacitated(&self) -> bool {
        self.pain > 0.9 || self.shock > 0.8
    }

    /// Update shock from blood loss
    pub fn update_shock(&mut self, blood_lost_ml: f32, total_blood_ml: f32) {
        let blood_loss_ratio = blood_lost_ml / total_blood_ml;

        // Shock onset accelerates with blood loss
        self.shock = match blood_loss_ratio {
            r if r < 0.1 => r * 0.5,           // Minor loss
            r if r < 0.2 => 0.05 + (r - 0.1) * 2.0,  // Class I hemorrhage
            r if r < 0.3 => 0.25 + (r - 0.2) * 3.0,  // Class II
            r if r < 0.4 => 0.55 + (r - 0.3) * 4.0,  // Class III
            r => 0.95 + (r - 0.4) * 0.5,             // Class IV (fatal)
        };
    }
}
```

### Blood Loss

```rust
/// Track blood state
#[derive(Clone, Debug)]
pub struct BloodState {
    /// Current blood volume in ml
    pub current_volume: f32,

    /// Total blood capacity in ml
    pub max_volume: f32,

    /// Active bleeding wounds
    pub bleeding_wounds: Vec<WoundId>,

    /// Total bleeding rate
    pub total_bleed_rate: f32,
}

impl BloodState {
    pub fn new(body_mass: f32) -> Self {
        // ~7% of body mass is blood
        let blood_volume = body_mass * 0.07 * 1000.0;  // ml

        BloodState {
            current_volume: blood_volume,
            max_volume: blood_volume,
            bleeding_wounds: Vec::new(),
            total_bleed_rate: 0.0,
        }
    }

    /// Update blood loss each tick
    pub fn tick(&mut self, dt: f32) {
        let blood_lost = self.total_bleed_rate * dt;
        self.current_volume = (self.current_volume - blood_lost).max(0.0);
    }

    /// Add a bleeding wound
    pub fn add_bleeding(&mut self, wound_id: WoundId, rate: f32) {
        self.bleeding_wounds.push(wound_id);
        self.total_bleed_rate += rate;
    }

    /// Blood loss ratio for shock calculation
    pub fn loss_ratio(&self) -> f32 {
        1.0 - (self.current_volume / self.max_volume)
    }

    /// Is blood loss fatal?
    pub fn is_fatal(&self) -> bool {
        self.current_volume < self.max_volume * 0.5
    }
}
```

### Limb Damage

```rust
/// Track damage to specific limbs
#[derive(Clone, Debug)]
pub struct LimbState {
    pub zone: BodyZone,
    pub hp_current: f32,
    pub hp_max: f32,
    pub is_usable: bool,
    pub is_destroyed: bool,
}

impl LimbState {
    /// Apply damage to limb
    pub fn apply_damage(&mut self, damage: f32) {
        self.hp_current = (self.hp_current - damage).max(0.0);

        // Check functionality
        if self.hp_current < self.hp_max * 0.25 {
            self.is_usable = false;
        }

        if self.hp_current <= 0.0 {
            self.is_destroyed = true;
        }
    }

    /// Can this limb hold a weapon?
    pub fn can_wield(&self) -> bool {
        self.is_usable && matches!(self.zone, BodyZone::Hand | BodyZone::Forearm | BodyZone::UpperArm)
    }

    /// Can this limb support movement?
    pub fn can_move(&self) -> bool {
        self.is_usable && matches!(self.zone, BodyZone::Thigh | BodyZone::Shin | BodyZone::Foot)
    }
}
```

---

## Ranged Combat

### Projectile Physics

```rust
/// Calculate projectile trajectory
pub fn calculate_trajectory(
    projectile: &ProjectilePhysics,
    launch_velocity: f32,
    launch_angle: f32,  // radians from horizontal
    distance: f32,
) -> ProjectileState {
    // Drag coefficient (simplified)
    let drag_coeff = 0.47;  // Sphere approximation
    let air_density = 1.225;  // kg/m³ at sea level

    // Cross-sectional area
    let area = std::f32::consts::PI * projectile.radius.powi(2);

    // Drag force = ½ρv²CdA
    // This is simplified - full trajectory would use numerical integration

    // Time of flight (ignoring drag for simplicity)
    let vx = launch_velocity * launch_angle.cos();
    let vy = launch_velocity * launch_angle.sin();

    // Time to target (horizontal)
    let time_of_flight = distance / vx;

    // Vertical drop
    let gravity = 9.81;
    let drop = 0.5 * gravity * time_of_flight.powi(2) - vy * time_of_flight;

    // Velocity at impact (energy loss from drag)
    let drag_factor = (-drag_coeff * air_density * area * distance / (2.0 * projectile.mass)).exp();
    let impact_velocity = launch_velocity * drag_factor;

    ProjectileState {
        velocity: impact_velocity,
        drop,
        time_of_flight,
        kinetic_energy: 0.5 * projectile.mass * impact_velocity.powi(2),
    }
}

#[derive(Clone, Debug)]
pub struct ProjectilePhysics {
    pub mass: f32,        // kg
    pub radius: f32,      // m (for drag calculation)
    pub tip_geometry: TipGeometry,
    pub material: Material,
}

#[derive(Clone, Copy, Debug)]
pub enum TipGeometry {
    Broadhead,    // Cutting tip
    Bodkin,       // Armor-piercing point
    Blunt,        // Hunting/stunning
    Barbed,       // Causes extra damage on removal
}

#[derive(Debug)]
pub struct ProjectileState {
    pub velocity: f32,
    pub drop: f32,
    pub time_of_flight: f32,
    pub kinetic_energy: f32,
}
```

### Bow Mechanics

```rust
/// Calculate arrow velocity from bow draw
pub fn calculate_launch_velocity(bow: &BowPhysics, draw_strength: f32, draw_length: f32) -> f32 {
    // Energy stored in bow
    // Simplified: E = ½kx² where k is draw weight per length
    let spring_constant = bow.draw_weight / bow.max_draw_length;
    let stored_energy = 0.5 * spring_constant * draw_length.powi(2);

    // Efficiency (not all energy transfers to arrow)
    let efficiency = bow.efficiency * (draw_strength / bow.min_draw_strength).min(1.0);

    // Arrow energy
    let arrow_energy = stored_energy * efficiency;

    // Velocity from energy: E = ½mv², v = √(2E/m)
    let arrow_mass = 0.025;  // 25g typical arrow
    (2.0 * arrow_energy / arrow_mass).sqrt()
}

#[derive(Clone, Debug)]
pub struct BowPhysics {
    pub draw_weight: f32,       // Newtons at full draw
    pub max_draw_length: f32,   // meters
    pub min_draw_strength: f32, // Strength needed for full draw
    pub efficiency: f32,        // Energy transfer ratio
}
```

---

## Integration

### Combat Resolution Flow

```rust
/// Complete melee attack resolution
pub fn resolve_melee_attack(
    attacker: &mut Combatant,
    defender: &mut Combatant,
    attack: &MeleeAttack,
    context: &CombatContext,
) -> AttackResult {
    // 1. Generate swing force
    let swing = calculate_swing_force(
        &attacker.weapon.physics,
        &attacker.stats,
        attack.swing_type,
        attacker.fatigue.exertion,
    );

    // 2. Check if attack hits (separate system)
    let hit_location = if let Some(loc) = attack.aimed_location {
        // Aimed attack has accuracy penalty
        determine_hit_location(attacker, defender, Some(loc), context)
    } else {
        determine_hit_location(attacker, defender, None, context)
    };

    let Some(location) = hit_location else {
        return AttackResult::Miss;
    };

    // 3. Calculate impact force
    let impact_type = attack.swing_type.to_impact_type(&attacker.weapon);
    let impact = calculate_impact_force(&swing, &attacker.weapon.physics, impact_type);

    // 4. Check armor penetration
    let penetration = if let Some(armor) = &defender.armor {
        penetration_check(&impact, &armor.physics, location)
    } else {
        PenetrationResult::NotCovered
    };

    // 5. Generate wound
    let tissue = defender.body.tissue_at(location);
    let wound = generate_wound(&impact, &penetration, location, &tissue);

    // 6. Apply wound effects
    if let Some(wound) = wound {
        defender.apply_wound(wound.clone());

        AttackResult::Hit {
            location,
            wound,
            penetration_type: penetration,
        }
    } else {
        AttackResult::NoEffect { location }
    }
}

#[derive(Debug)]
pub enum AttackResult {
    Miss,
    NoEffect { location: BodyZone },
    Hit {
        location: BodyZone,
        wound: Wound,
        penetration_type: PenetrationResult,
    },
}
```

---

## Related Specifications

| Document | Relationship |
|----------|--------------|
| [05-BATTLE-SYSTEM-SPEC](05-BATTLE-SYSTEM-SPEC.md) | High-level combat system |
| [06-BALANCE-COMPOSITION-SPEC](06-BALANCE-COMPOSITION-SPEC.md) | Balance philosophy |
| [12-BATTLE-PLANNING-TERRAIN-SPEC](12-BATTLE-PLANNING-TERRAIN-SPEC.md) | Terrain effects |
| [13-MODULE-SCHEMA-SPEC](13-MODULE-SCHEMA-SPEC.md) | Weapon/armor schemas |

---

## Changelog

| Date | Change |
|------|--------|
| 2026-01-14 | Initial specification created |
